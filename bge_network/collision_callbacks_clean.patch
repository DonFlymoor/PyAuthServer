Index: doc/python_api/rst/bge_types/bge.types.KX_GameObject.rst
===================================================================
--- doc/python_api/rst/bge_types/bge.types.KX_GameObject.rst	(revision 57623)
+++ doc/python_api/rst/bge_types/bge.types.KX_GameObject.rst	(working copy)
@@ -134,6 +134,12 @@
 
       :type: :class:`KX_GameObject` or None
 
+   .. attribute:: collisionCallbacks
+
+      A list of callables to be run when a collision occurs.
+
+      :type: list
+	  
    .. attribute:: scene
 
       The object's scene. (read-only).
Index: source/gameengine/Ketsji/KX_GameObject.cpp
===================================================================
--- source/gameengine/Ketsji/KX_GameObject.cpp	(revision 57623)
+++ source/gameengine/Ketsji/KX_GameObject.cpp	(working copy)
@@ -111,8 +111,10 @@
       m_pDupliGroupObject(NULL),
       m_actionManager(NULL),
       m_isDeformable(false)
+
 #ifdef WITH_PYTHON
-    , m_attr_dict(NULL)
+    , m_attr_dict(NULL),
+	m_collisionCallbacks(NULL)
 #endif
 {
 	m_ignore_activity_culling = false;
@@ -177,12 +179,18 @@
 	{
 		m_pInstanceObjects->Release();
 	}
+
 #ifdef WITH_PYTHON
 	if (m_attr_dict) {
 		PyDict_Clear(m_attr_dict); /* in case of circular refs or other weird cases */
 		/* Py_CLEAR: Py_DECREF's and NULL's */
 		Py_CLEAR(m_attr_dict);
 	}
+	// Unregister collision callbacks
+	if (m_collisionCallbacks){
+		UnregisterCollisionCallbacks();
+		Py_CLEAR(m_collisionCallbacks);
+	}
 #endif // WITH_PYTHON
 }
 
@@ -1332,6 +1340,69 @@
 }
 
 
+void KX_GameObject::UnregisterCollisionCallbacks()
+{
+	// Unregister from callbacks
+	KX_Scene* scene = GetScene();
+	PHY_IPhysicsEnvironment* pe = scene->GetPhysicsEnvironment();
+	PHY_IPhysicsController* spc = static_cast<PHY_IPhysicsController*> (GetPhysicsController()->GetUserData());
+	// If we are the last to unregister on this physics controller 
+	if (pe->removeCollisionCallback(spc)){
+		// If we are a sensor object
+		KX_ClientObjectInfo *client_info = static_cast<KX_ClientObjectInfo*>(spc->getNewClientInfo());
+		if (client_info->isSensor())
+			// Remove sensor body from physics world
+			pe->removeSensor(spc);
+	}
+}
+
+void KX_GameObject::RegisterCollisionCallbacks()
+{	
+	// Register from callbacks
+	KX_Scene* scene = GetScene();
+	PHY_IPhysicsEnvironment* pe = scene->GetPhysicsEnvironment();
+	PHY_IPhysicsController* spc = static_cast<PHY_IPhysicsController*> (GetPhysicsController()->GetUserData());
+	// If we are the first to register on this physics controller 
+	if (pe->requestCollisionCallback(spc)){
+		// If we are a sensor object
+		KX_ClientObjectInfo *client_info = static_cast<KX_ClientObjectInfo*>(spc->getNewClientInfo());
+		if (client_info->isSensor())
+			// Add sensor body to physics world
+			pe->addSensor(spc);
+	}
+}
+void KX_GameObject::RunCollisionCallbacks(KX_GameObject *collider)
+{	
+	#ifdef WITH_PYTHON
+	Py_ssize_t len;
+	PyObject* collision_callbacks = m_collisionCallbacks;
+
+	if (collision_callbacks && (len=PyList_GET_SIZE(collision_callbacks)))
+	{
+		PyObject* args = Py_BuildValue("(O)", collider->GetProxy()); // save python creating each call
+		PyObject *func;
+		PyObject *ret;
+
+		// Iterate the list and run the callbacks
+		for (Py_ssize_t pos=0; pos < len; pos++)
+		{
+			func = PyList_GET_ITEM(collision_callbacks, pos);
+			ret = PyObject_Call(func, args, NULL);
+
+			if (ret == NULL) {
+				PyErr_Print();
+				PyErr_Clear();
+			}
+			else {
+				Py_DECREF(ret);
+			}
+		}
+
+		Py_DECREF(args);
+	}
+	#endif
+}
+
 /* Suspend/ resume: for the dynamic behavior, there is a simple
  * method. For the residual motion, there is not. I wonder what the
  * correct solution is for Sumo. Remove from the motion-update tree?
@@ -1712,6 +1783,7 @@
 	KX_PYATTRIBUTE_RW_FUNCTION("orientation",KX_GameObject,pyattr_get_worldOrientation,pyattr_set_localOrientation),
 	KX_PYATTRIBUTE_RW_FUNCTION("scaling",	KX_GameObject, pyattr_get_worldScaling,	pyattr_set_localScaling),
 	KX_PYATTRIBUTE_RW_FUNCTION("timeOffset",KX_GameObject, pyattr_get_timeOffset,pyattr_set_timeOffset),
+	KX_PYATTRIBUTE_RW_FUNCTION("collisionCallbacks",		KX_GameObject, pyattr_get_collisionCallbacks,	pyattr_set_collisionCallbacks),
 	KX_PYATTRIBUTE_RW_FUNCTION("state",		KX_GameObject, pyattr_get_state,	pyattr_set_state),
 	KX_PYATTRIBUTE_RO_FUNCTION("meshes",	KX_GameObject, pyattr_get_meshes),
 	KX_PYATTRIBUTE_RW_FUNCTION("localOrientation",KX_GameObject,pyattr_get_localOrientation,pyattr_set_localOrientation),
@@ -2004,6 +2076,38 @@
 	Py_RETURN_NONE;
 }
 
+PyObject* KX_GameObject::pyattr_get_collisionCallbacks(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef)
+{
+	KX_GameObject* self = static_cast<KX_GameObject*>(self_v);
+	// Return the existing callbacks
+	if (self->m_collisionCallbacks == NULL)
+	{
+		self->m_collisionCallbacks = PyList_New(0);
+		// Subscribe to collision update from KX_TouchManager
+		self->RegisterCollisionCallbacks();
+	}
+	Py_INCREF(self->m_collisionCallbacks);
+	return self->m_collisionCallbacks;
+}
+
+int KX_GameObject::pyattr_set_collisionCallbacks(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef, PyObject *value)
+{
+	KX_GameObject* self = static_cast<KX_GameObject*>(self_v);
+	
+	if (!PyList_CheckExact(value))
+	{
+		PyErr_SetString(PyExc_ValueError, "Expected a list");
+		return PY_SET_ATTR_FAIL;
+	}
+
+	Py_XDECREF(self->m_collisionCallbacks);
+	Py_INCREF(value);
+
+	self->m_collisionCallbacks = value;
+	
+	return PY_SET_ATTR_SUCCESS;
+}
+
 PyObject* KX_GameObject::pyattr_get_scene(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef)
 {
 	KX_GameObject *self = static_cast<KX_GameObject*>(self_v);
Index: source/gameengine/Ketsji/KX_GameObject.h
===================================================================
--- source/gameengine/Ketsji/KX_GameObject.h	(revision 57623)
+++ source/gameengine/Ketsji/KX_GameObject.h	(working copy)
@@ -152,6 +152,7 @@
 	// * when assigning a value, first see if it can be a CValue, if it can remove the "m_attr_dict" and set the CValue
 	// 
 	PyObject*							m_attr_dict; 
+	PyObject*							m_collisionCallbacks; 
 #endif
 
 	virtual void	/* This function should be virtual - derived classed override it */
@@ -871,6 +872,9 @@
 	 * \section Logic bubbling methods.
 	 */
 
+	void RegisterCollisionCallbacks();
+	void UnregisterCollisionCallbacks();
+	void RunCollisionCallbacks(KX_GameObject *collider);
 	/**
 	 * Stop making progress
 	 */
@@ -1039,6 +1043,8 @@
 	static PyObject*	pyattr_get_attrDict(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef);
 	static PyObject*	pyattr_get_obcolor(void *selv_v, const KX_PYATTRIBUTE_DEF *attrdef);
 	static int			pyattr_set_obcolor(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef, PyObject *value);
+	static PyObject*	pyattr_get_collisionCallbacks(void *selv_v, const KX_PYATTRIBUTE_DEF *attrdef);
+	static int			pyattr_set_collisionCallbacks(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef, PyObject *value);
 	
 	/* Experimental! */
 	static PyObject*	pyattr_get_sensors(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef);
Index: source/gameengine/Ketsji/KX_TouchEventManager.cpp
===================================================================
--- source/gameengine/Ketsji/KX_TouchEventManager.cpp	(revision 57623)
+++ source/gameengine/Ketsji/KX_TouchEventManager.cpp	(working copy)
@@ -81,28 +81,42 @@
 							void *object2,
 							const PHY_CollData *coll_data)
 {
-	PHY_IPhysicsController* ctrl = static_cast<PHY_IPhysicsController*>(object1);
-	KX_ClientObjectInfo *info = (ctrl) ? static_cast<KX_ClientObjectInfo*>(ctrl->getNewClientInfo()) : NULL;
+	PHY_IPhysicsController* ctrl1 = static_cast<PHY_IPhysicsController*>(object1);
+	PHY_IPhysicsController* ctrl2 = static_cast<PHY_IPhysicsController*>(object2);
+
+	KX_ClientObjectInfo *info1 = (ctrl1) ? static_cast<KX_ClientObjectInfo*>(ctrl1->getNewClientInfo()) : NULL;
+	KX_ClientObjectInfo *info2 = (ctrl1) ? static_cast<KX_ClientObjectInfo*>(ctrl2->getNewClientInfo()) : NULL;
+
 	// This call back should only be called for controllers of Near and Radar sensor
-	if (!info)
+	if (!info1)
 		return true;
+	
+	// Get KX_GameObjects for callbacks
+	KX_GameObject* gobj1 = info1->m_gameobject;
+	KX_GameObject* gobj2 = (info2) ? info1->m_gameobject : NULL;
+	
+	bool has_py_callbacks;
 
-	switch (info->m_type)
+	// Consider callbacks for broadphase inclusion if it's a sensor object type
+	if (gobj1 && gobj2)
+		has_py_callbacks = gobj1->m_collisionCallbacks || gobj2->m_collisionCallbacks;
+
+	switch (info1->m_type)
 	{
 	case KX_ClientObjectInfo::SENSOR:
-		if (info->m_sensors.size() == 1)
+		if (info1->m_sensors.size() == 1)
 		{
 			// only one sensor for this type of object
-			KX_TouchSensor* touchsensor = static_cast<KX_TouchSensor*>(*info->m_sensors.begin());
-			return touchsensor->BroadPhaseFilterCollision(object1,object2);
+			KX_TouchSensor* touchsensor = static_cast<KX_TouchSensor*>(*info1->m_sensors.begin());
+			return touchsensor->BroadPhaseFilterCollision(object1, object2);
 		}
 		break;
 	case KX_ClientObjectInfo::OBSENSOR:
 	case KX_ClientObjectInfo::OBACTORSENSOR:
 		// this object may have multiple collision sensors, 
 		// check is any of them is interested in this object
-		for (std::list<SCA_ISensor*>::iterator it = info->m_sensors.begin();
-			it != info->m_sensors.end();
+		for (std::list<SCA_ISensor*>::iterator it = info1->m_sensors.begin();
+			it != info1->m_sensors.end();
 			++it)
 		{
 			if ((*it)->GetSensorType() == SCA_ISensor::ST_TOUCH) 
@@ -112,8 +126,9 @@
 					return true;
 			}
 		}
-		return false;
 
+		return has_py_callbacks;
+
 	// quiet the compiler
 	case KX_ClientObjectInfo::STATIC:
 	case KX_ClientObjectInfo::ACTOR:
@@ -155,32 +170,44 @@
 
 void KX_TouchEventManager::NextFrame()
 {
-	if (!m_sensors.Empty())
-	{
+	
 		SG_DList::iterator<KX_TouchSensor> it(m_sensors);
 		for (it.begin();!it.end();++it)
 			(*it)->SynchronizeTransform();
 		
 		for (std::set<NewCollision>::iterator cit = m_newCollisions.begin(); cit != m_newCollisions.end(); ++cit)
-		{
+		{			
+			// Controllers
 			PHY_IPhysicsController* ctrl1 = (*cit).first;
-//			PHY_IPhysicsController* ctrl2 = (*cit).second;
-//			KX_GameObject* gameOb1 = ctrl1->getClientInfo();
-//			KX_GameObject* gameOb1 = ctrl1->getClientInfo();
+			PHY_IPhysicsController* ctrl2 = (*cit).second;
 
-			KX_ClientObjectInfo *client_info = static_cast<KX_ClientObjectInfo *>(ctrl1->getNewClientInfo());
+			// Sensor iterator
 			list<SCA_ISensor*>::iterator sit;
+
+			// First client info
+			KX_ClientObjectInfo *client_info = static_cast<KX_ClientObjectInfo*>(ctrl1->getNewClientInfo());
+			// First gameobject
+			KX_GameObject *kxObj1 = KX_GameObject::GetClientObject(client_info);
+			// Invoke sensor response for each object
 			if (client_info) {
 				for ( sit = client_info->m_sensors.begin(); sit != client_info->m_sensors.end(); ++sit) {
-					static_cast<KX_TouchSensor*>(*sit)->NewHandleCollision((*cit).first, (*cit).second, NULL);
+					static_cast<KX_TouchSensor*>(*sit)->NewHandleCollision(ctrl1, ctrl2, NULL);
 				}
-			}
-			client_info = static_cast<KX_ClientObjectInfo *>((*cit).second->getNewClientInfo());
+ 			}
+
+			// Second client info
+			client_info = static_cast<KX_ClientObjectInfo *>(ctrl2->getNewClientInfo());
+			// Second gameobject
+			KX_GameObject *kxObj2 = KX_GameObject::GetClientObject(client_info);	
 			if (client_info) {
 				for ( sit = client_info->m_sensors.begin(); sit != client_info->m_sensors.end(); ++sit) {
-					static_cast<KX_TouchSensor*>(*sit)->NewHandleCollision((*cit).second, (*cit).first, NULL);
-				}
-			}
+					static_cast<KX_TouchSensor*>(*sit)->NewHandleCollision(ctrl2, ctrl1, NULL);
+ 				}
+ 			}
+			// Run python callbacks
+			kxObj1->RunCollisionCallbacks(kxObj2);
+			kxObj2->RunCollisionCallbacks(kxObj1);
+
 		}
 			
 		m_newCollisions.clear();
@@ -188,4 +215,3 @@
 		for (it.begin();!it.end();++it)
 			(*it)->Activate(m_logicmgr);
 	}
-}
