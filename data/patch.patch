Index: doc/python_api/rst/bge.logic.rst
===================================================================
--- doc/python_api/rst/bge.logic.rst	(revision 60397)
+++ doc/python_api/rst/bge.logic.rst	(working copy)
@@ -304,7 +304,40 @@
    
    :return: The logic frequency in Hz
    :rtype: float
+   
+.. function:: getAnimationTicRate()
 
+   Gets the animation update frequency.
+   
+   :return: The animation frequency in Hz
+   :rtype: float
+   
+.. function:: setAnimationTicRate(ticrate)
+
+   Sets the animation update frequency.
+   
+   The animation update frequency is the number of animation frames per second.
+   The default is 24 Hz if using fixed animation rate.
+   
+   :arg ticrate: The new animation update frequency (in Hz).
+   :type ticrate: float
+   
+.. function:: getRestrictAnimationUpdates()
+
+   Gets the animation respect frame rate status
+   
+   :return: The fixed animation framerate value
+   :rtype: bool
+   
+.. function:: setRestrictAnimationUpdates(restrict)
+
+   Sets the animation respect frame rate status
+   
+   This toggles the animation system ability to use a fixed framerate.
+   
+   :arg restrict: The new fixed animation framerate value.
+   :type restrict: bool
+
 .. function:: setLogicTicRate(ticrate)
 
    Sets the logic update frequency.
@@ -336,13 +369,27 @@
 
    .. warning: Not implimented yet
 
-.. function:: getExitKey()
+.. function:: getUseFrameRate()
 
    Gets the key used to exit the game engine
 
    :return: The key (defaults to :mod:`bge.events.ESCKEY`)
    :rtype: int
 
+.. function:: setUseFrameRate(status)
+
+   Sets the option to use a fixed framerate, rather than render as many frames as possible
+
+   :arg status: The new use framerate value
+   :type key: bool
+   
+.. function:: getUseFrameRate()
+
+   Gets the option to use a fixed framerate, rather than render as many frames as possible
+
+   :return: The use framerate value
+   :rtype: bool
+
 .. function:: setExitKey(key)
 
    Sets the key used to exit the game engine
@@ -350,10 +397,6 @@
    :arg key: A key constant from :mod:`bge.events`
    :type key: int
 
-.. function:: NextFrame()
-
-   Render next frame (if Python has control)
-
 *****************
 Utility functions
 *****************
@@ -1091,6 +1134,20 @@
 .. data:: KX_INPUT_ACTIVE
 .. data:: KX_INPUT_JUST_RELEASED
 
+------------
+Physics Type
+------------
+.. _gameobject-physics-type:
+.. data:: KX_PHYSICS_STATIC
+.. data:: KX_PHYSICS_DYNAMIC
+.. data:: KX_PHYSICS_SENSOR
+.. data:: KX_PHYSICS_CHARACTER
+.. data:: KX_PHYSICS_OCCLUDER
+.. data:: KX_PHYSICS_SOFT_BODY
+.. data:: KX_PHYSICS_RIGID_BODY
+.. data:: KX_PHYSICS_NAVIGATION_MESH
+.. data:: KX_PHYSICS_NO_COLLISION
+
 -------------
 KX_GameObject
 -------------
@@ -1140,6 +1197,48 @@
 .. data:: KX_MOUSE_BUT_MIDDLE
 .. data:: KX_MOUSE_BUT_RIGHT
 
+--------------------
+Profile category IDs
+--------------------
+
+.. _profile_category_id:
+
+.. data:: KX_ENGINE_DEBUG_PHYSICS
+
+   Physics profile category ID.
+   
+.. data:: KX_ENGINE_DEBUG_ANIMATION
+
+   Animation profile category ID.
+   
+.. data:: KX_ENGINE_DEBUG_MESSAGES
+
+   Messages profile category ID.
+    
+.. data:: KX_ENGINE_DEBUG_LOGIC
+
+   Logic profile category ID.
+       
+.. data:: KX_ENGINE_DEBUG_SCENEGRAPH
+
+   Scenegraph profile category ID.
+          
+.. data:: KX_ENGINE_DEBUG_RASTERIZER
+
+   Rasterizer profile category ID.
+            
+.. data:: KX_ENGINE_DEBUG_SERVICES
+
+   Services profile category ID.
+               
+.. data:: KX_ENGINE_DEBUG_OVERHEAD
+
+   Overhead profile category ID.
+               
+.. data:: KX_ENGINE_DEBUG_OUTSIDE
+
+   Outside profile category ID.
+   
 --------------------------
 Navigation Mesh Draw Modes
 --------------------------
Index: doc/python_api/rst/bge_types/bge.types.KX_GameObject.rst
===================================================================
--- doc/python_api/rst/bge_types/bge.types.KX_GameObject.rst	(revision 60397)
+++ doc/python_api/rst/bge_types/bge.types.KX_GameObject.rst	(working copy)
@@ -134,12 +134,21 @@
 
       :type: :class:`KX_GameObject` or None
 
+<<<<<<< .mine
    .. attribute:: collisionCallbacks
 
       A list of callables to be run when a collision occurs.
 
       :type: list
+	  
+=======
+   .. attribute:: collisionCallbacks
 
+      A list of callables to be run when a collision occurs.
+
+      :type: list
+
+>>>>>>> .r60397
    .. attribute:: scene
 
       The object's scene. (read-only).
@@ -276,6 +285,20 @@
 
       :type: int
 
+   .. attribute:: physicsType
+
+      Type of physics mode, (read-only).
+
+      Use one of :ref:`these constants<gameobject-physics-type>`.
+      
+      :type: integer, one of KX_PHYSICS_* constants
+
+   .. attribute:: isActor
+
+      If the object is an Actor, (read-only).
+      
+      :type: boolean
+	  
    .. attribute:: meshes
 
       a list meshes for this object.
Index: doc/python_api/rst/bge_types/bge.types.KX_PythonLogicLoop.rst
===================================================================
--- doc/python_api/rst/bge_types/bge.types.KX_PythonLogicLoop.rst	(revision 0)
+++ doc/python_api/rst/bge_types/bge.types.KX_PythonLogicLoop.rst	(working copy)
@@ -0,0 +1,185 @@
+KX_PythonLogicLoop(PyObjectPlus)
+================================
+
+.. module:: bge.types
+
+base class --- :class:`PyObjectPlus`
+
+.. class:: KX_PythonLogicLoop(PyObjectPlus)
+
+   A Python base class for a Logic Loop.
+
+   .. method:: main()
+
+      The entry point into the logic loop
+	  .. code-block:: python
+
+		from bge import logic, events, types
+
+		class Loop(types.KX_PythonLogicLoop):
+				
+			def __init__(self):
+				self.pause = False
+				self.framerate = 60
+				
+				self.last_time = self.get_time()
+				self.last_anim_time = self.get_time()
+			
+			def main(self):    
+				# Run whilst the engine allows us
+				while not self.check_quit():
+								
+					# Setup frame
+					self.start_profile(logic.KX_ENGINE_DEBUG_SERVICES)
+					
+					start_time = current_time = self.get_time()
+					deltatime = current_time - self.last_time
+					
+					# Check if the system wishes to run animation at a fixed rate
+					restrict_animation_fps = logic.getRestrictAnimationUpdates()
+					use_fixed_framerate = logic.getUseFrameRate()
+					
+					# Fixed frame rate requires skipping frames
+					if use_fixed_framerate:
+						if deltatime < (1 /  self.framerate):
+							continue
+		 
+					# Update blender events
+					self.update_blender()
+					
+					# Receive messages
+					self.start_profile(logic.KX_ENGINE_DEBUG_MESSAGES)
+					self.receive_messages(current_time)
+					
+					for scene in logic.getSceneList():
+						self.start_profile(logic.KX_ENGINE_DEBUG_LOGIC)
+						
+						# Set current game scene
+						self.set_current_scene(scene)
+						current_time = self.get_time()
+										   
+						if not self.pause:                    
+							self.start_profile(logic.KX_ENGINE_DEBUG_PHYSICS)
+							self.update_physics(current_time, deltatime)
+							
+							self.start_profile(logic.KX_ENGINE_DEBUG_SCENEGRAPH)
+							self.update_scenegraph(current_time)
+							
+							if not restrict_animation_fps:
+								self.update_animations(current_time)
+								
+					# Treat the rest as outside
+					self.start_profile(logic.KX_ENGINE_DEBUG_OUTSIDE)
+					
+					# If animations must run at a fixed framerate
+					if restrict_animation_fps:
+						self.start_profile(logic.KX_ENGINE_DEBUG_ANIMATIONS)
+						
+						animation_timestep = 1 / logic.getAnimationTicRate()
+						
+						if (current_time - self.last_anim_time) > animation_timestep:
+							self.last_anim_time = current_time
+							
+							for scene in logic.getSceneList():
+								self.set_current_scene(scene)
+								self.update_animations(current_time)
+											
+					# Called after logic updated
+					self.start_profile(logic.KX_ENGINE_DEBUG_SERVICES)
+					self.update_keyboard()
+					self.update_mouse()
+					self.update_messages()
+					self.update_scenes()
+
+					# Finally we render
+					self.start_profile(logic.KX_ENGINE_DEBUG_RASTERIZER)
+					self.update_render()    
+					
+					# And rest is delegated to outside
+					self.start_profile(logic.KX_ENGINE_DEBUG_OUTSIDE) 
+					self.last_time = start_time
+
+   .. method:: start_profile(profile_id, stop_others=True, current_time=None)
+
+      Informs the KX_KetsjiEngine to start profiling a profile category
+	  By default, the method will stop other categories (to run sequentially)
+	  If no time value is passed, it will use the internal current time
+
+      :arg profile_id: The ID of the profile category, can be one of :ref:`these constants <profile_category_id>`
+      :type scene: int
+      :arg stop_others: A switch that will stop other profiling categories
+      :type scene: bool
+      :arg current_time: The start time of the profile call
+      :type scene: float
+	  
+   .. method:: stop_profile(profile_id, current_time=None)
+
+      Informs the KX_KetsjiEngine to stop profiling a profile category
+	  If no time value is passed, it will use the internal current time
+
+      :arg profile_id: The ID of the profile category, can be one of :ref:`these constants <profile_category_id>`
+      :type scene: int
+      :arg current_time: The stop time of the profile call
+      :type scene: float
+	  
+   .. method:: update_render()
+
+      Invokes a render step
+	 
+   .. method:: update_blender()
+
+      Updates keyboard and mouse events from Blender
+	  
+   .. method:: update_messages()
+
+      Informs the message loopback that one frame has elapsed
+	  
+   .. method:: update_keyboard()
+
+      Informs the BGE keyboard that one frame has elapsed
+
+   .. method:: update_scenes()
+
+      Updates the scene management (add/remove scenes)
+	  
+   .. method:: update_physics(current_time, deltatime)
+
+      Updates physics for the current internally active scene
+	  :arg current_time: The current time of the update
+      :type scene: float
+      :arg deltatime: The deltatime since last frame
+      :type scene: float
+
+   .. method:: receive_messages()
+
+      Refreshes messages from the loopback interface
+	  
+   .. method:: update_scenegraph()
+
+      Updates the scene graph for the current internally active scene
+	  	  
+   .. method:: update_animations()
+
+      Updates the animations for the current internally active scene
+	  	  	  
+   .. method:: set_current_scene(scene)
+
+      Sets the current internally active scene
+	  :arg scene: The scene to set as active
+      :type scene: :class:`KX_Scene`
+
+   .. method:: check_quit()
+   
+	  Returns the exit status of the engine
+	  
+	  :return: The exit status of the engine
+	  :rtype: bool
+
+   .. method:: get_time()
+   
+	  Returns the current internal time of the engine
+	  
+	  :return: The current time
+	  :rtype: float
+	  
+	  
\ No newline at end of file
Index: doc/python_api/rst/bge_types/bge.types.KX_Scene.rst
===================================================================
--- doc/python_api/rst/bge_types/bge.types.KX_Scene.rst	(revision 60397)
+++ doc/python_api/rst/bge_types/bge.types.KX_Scene.rst	(working copy)
@@ -125,16 +125,18 @@
 
       :type: list [fx, fy, fz]
 
-   .. method:: addObject(object, other, time=0)
+   .. method:: addObject(object, other, time=0, layer=0)
 
       Adds an object to the scene like the Add Object Actuator would.
 
       :arg object: The object to add
       :type object: :class:`KX_GameObject` or string
-      :arg other: The object's center to use when adding the object
-      :type other: :class:`KX_GameObject` or string
+      :arg other: The source for the new transform, using an object, or transform matrix
+      :type other: :class:`KX_GameObject`, :class:`Matrix` or string
       :arg time: The lifetime of the added object, in frames. A time of 0 means the object will last forever.
       :type time: integer
+      :arg layer: The layer of the added object. This should only be specified if a matrix is used, otherwise it is ignored.
+      :type layer: integer
       :return: The newly added object.
       :rtype: :class:`KX_GameObject`
 
Index: release/scripts/startup/bl_ui/properties_game.py
===================================================================
--- release/scripts/startup/bl_ui/properties_game.py	(revision 60397)
+++ release/scripts/startup/bl_ui/properties_game.py	(working copy)
@@ -22,284 +22,302 @@
 
 
 class PhysicsButtonsPanel():
-    bl_space_type = 'PROPERTIES'
-    bl_region_type = 'WINDOW'
-    bl_context = "physics"
+	bl_space_type = 'PROPERTIES'
+	bl_region_type = 'WINDOW'
+	bl_context = "physics"
 
 
 class PHYSICS_PT_game_physics(PhysicsButtonsPanel, Panel):
-    bl_label = "Physics"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Physics"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    @classmethod
-    def poll(cls, context):
-        ob = context.active_object
-        rd = context.scene.render
-        return ob and ob.game and (rd.engine in cls.COMPAT_ENGINES)
+	@classmethod
+	def poll(cls, context):
+		ob = context.active_object
+		rd = context.scene.render
+		return ob and ob.game and (rd.engine in cls.COMPAT_ENGINES)
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        ob = context.active_object
-        game = ob.game
-        soft = ob.game.soft_body
+		ob = context.active_object
+		game = ob.game
+		soft = ob.game.soft_body
 
-        layout.prop(game, "physics_type")
-        layout.separator()
+		layout.prop(game, "physics_type")
+		layout.separator()
 
-        physics_type = game.physics_type
+		physics_type = game.physics_type
 
-        if physics_type == 'CHARACTER':
-            layout.prop(game, "use_actor")
-            layout.prop(ob, "hide_render", text="Invisible")  # out of place but useful
-            layout.prop(game, "step_height", slider=True)
-            layout.prop(game, "jump_speed")
-            layout.prop(game, "fall_speed")
+		if physics_type == 'CHARACTER':
+			layout.prop(game, "use_actor")
+			layout.prop(ob, "hide_render", text="Invisible")  # out of place but useful
+			layout.prop(game, "step_height", slider=True)
+			layout.prop(game, "jump_speed")
+			layout.prop(game, "fall_speed")
 
-        elif physics_type in {'DYNAMIC', 'RIGID_BODY'}:
-            split = layout.split()
+		elif physics_type in {'DYNAMIC', 'RIGID_BODY'}:
+			split = layout.split()
 
-            col = split.column()
-            col.prop(game, "use_actor")
-            col.prop(game, "use_ghost")
-            col.prop(ob, "hide_render", text="Invisible")  # out of place but useful
+			col = split.column()
+			col.prop(game, "use_actor")
+			col.prop(game, "use_ghost")
+			col.prop(ob, "hide_render", text="Invisible")  # out of place but useful
 
-            col = split.column()
-            col.prop(game, "use_material_physics_fh")
-            col.prop(game, "use_rotate_from_normal")
-            col.prop(game, "use_sleep")
+			col = split.column()
+			col.prop(game, "use_material_physics_fh")
+			col.prop(game, "use_rotate_from_normal")
+			col.prop(game, "use_sleep")
 
-            layout.separator()
+			layout.separator()
 
-            split = layout.split()
+			split = layout.split()
 
-            col = split.column()
-            col.label(text="Attributes:")
-            col.prop(game, "mass")
-            col.prop(game, "radius")
-            col.prop(game, "form_factor")
+			col = split.column()
+			col.label(text="Attributes:")
+			col.prop(game, "mass")
+			col.prop(game, "radius")
+			col.prop(game, "form_factor")
 
-            col = split.column()
-            sub = col.column()
-            sub.prop(game, "use_anisotropic_friction")
-            subsub = sub.column()
-            subsub.active = game.use_anisotropic_friction
-            subsub.prop(game, "friction_coefficients", text="", slider=True)
+			col = split.column()
+			sub = col.column()
+			sub.prop(game, "use_anisotropic_friction")
+			subsub = sub.column()
+			subsub.active = game.use_anisotropic_friction
+			subsub.prop(game, "friction_coefficients", text="", slider=True)
 
-            split = layout.split()
+			split = layout.split()
 
-            col = split.column()
-            col.label(text="Velocity:")
-            sub = col.column(align=True)
-            sub.prop(game, "velocity_min", text="Minimum")
-            sub.prop(game, "velocity_max", text="Maximum")
+			col = split.column()
+			col.label(text="Velocity:")
+			sub = col.column(align=True)
+			sub.prop(game, "velocity_min", text="Minimum")
+			sub.prop(game, "velocity_max", text="Maximum")
 
-            col = split.column()
-            col.label(text="Damping:")
-            sub = col.column(align=True)
-            sub.prop(game, "damping", text="Translation", slider=True)
-            sub.prop(game, "rotation_damping", text="Rotation", slider=True)
+			col = split.column()
+			col.label(text="Damping:")
+			sub = col.column(align=True)
+			sub.prop(game, "damping", text="Translation", slider=True)
+			sub.prop(game, "rotation_damping", text="Rotation", slider=True)
 
-            layout.separator()
+			layout.separator()
 
-            split = layout.split()
+			split = layout.split()
 
-            col = split.column()
-            col.label(text="Lock Translation:")
-            col.prop(game, "lock_location_x", text="X")
-            col.prop(game, "lock_location_y", text="Y")
-            col.prop(game, "lock_location_z", text="Z")
+			col = split.column()
+			col.label(text="Lock Translation:")
+			col.prop(game, "lock_location_x", text="X")
+			col.prop(game, "lock_location_y", text="Y")
+			col.prop(game, "lock_location_z", text="Z")
 
-            col = split.column()
-            col.label(text="Lock Rotation:")
-            col.prop(game, "lock_rotation_x", text="X")
-            col.prop(game, "lock_rotation_y", text="Y")
-            col.prop(game, "lock_rotation_z", text="Z")
+			col = split.column()
+			col.label(text="Lock Rotation:")
+			col.prop(game, "lock_rotation_x", text="X")
+			col.prop(game, "lock_rotation_y", text="Y")
+			col.prop(game, "lock_rotation_z", text="Z")
 
-        elif physics_type == 'SOFT_BODY':
-            col = layout.column()
-            col.prop(game, "use_actor")
-            col.prop(game, "use_ghost")
-            col.prop(ob, "hide_render", text="Invisible")
+		elif physics_type == 'SOFT_BODY':
+			col = layout.column()
+			col.prop(game, "use_actor")
+			col.prop(game, "use_ghost")
+			col.prop(ob, "hide_render", text="Invisible")
 
-            layout.separator()
+			layout.separator()
 
-            split = layout.split()
+			split = layout.split()
 
-            col = split.column()
-            col.label(text="Attributes:")
-            col.prop(game, "mass")
-            # disabled in the code
-            # col.prop(soft, "weld_threshold")
-            col.prop(soft, "location_iterations")
-            col.prop(soft, "linear_stiffness", slider=True)
-            col.prop(soft, "dynamic_friction", slider=True)
-            col.prop(soft, "collision_margin", slider=True)
-            col.prop(soft, "use_bending_constraints", text="Bending Constraints")
+			col = split.column()
+			col.label(text="Attributes:")
+			col.prop(game, "mass")
+			# disabled in the code
+			# col.prop(soft, "weld_threshold")
+			col.prop(soft, "location_iterations")
+			col.prop(soft, "linear_stiffness", slider=True)
+			col.prop(soft, "dynamic_friction", slider=True)
+			col.prop(soft, "collision_margin", slider=True)
+			col.prop(soft, "use_bending_constraints", text="Bending Constraints")
 
-            col = split.column()
-            col.prop(soft, "use_shape_match")
-            sub = col.column()
-            sub.active = soft.use_shape_match
-            sub.prop(soft, "shape_threshold", slider=True)
+			col = split.column()
+			col.prop(soft, "use_shape_match")
+			sub = col.column()
+			sub.active = soft.use_shape_match
+			sub.prop(soft, "shape_threshold", slider=True)
 
-            col.separator()
+			col.separator()
 
-            col.label(text="Cluster Collision:")
-            col.prop(soft, "use_cluster_rigid_to_softbody")
-            col.prop(soft, "use_cluster_soft_to_softbody")
-            sub = col.column()
-            sub.active = (soft.use_cluster_rigid_to_softbody or soft.use_cluster_soft_to_softbody)
-            sub.prop(soft, "cluster_iterations", text="Iterations")
+			col.label(text="Cluster Collision:")
+			col.prop(soft, "use_cluster_rigid_to_softbody")
+			col.prop(soft, "use_cluster_soft_to_softbody")
+			sub = col.column()
+			sub.active = (soft.use_cluster_rigid_to_softbody or soft.use_cluster_soft_to_softbody)
+			sub.prop(soft, "cluster_iterations", text="Iterations")
 
-        elif physics_type == 'STATIC':
-            col = layout.column()
-            col.prop(game, "use_actor")
-            col.prop(game, "use_ghost")
-            col.prop(ob, "hide_render", text="Invisible")
+		elif physics_type == 'STATIC':
+			col = layout.column()
+			col.prop(game, "use_actor")
+			col.prop(game, "use_ghost")
+			col.prop(ob, "hide_render", text="Invisible")
 
-            layout.separator()
+			layout.separator()
 
-            split = layout.split()
+			split = layout.split()
 
-            col = split.column()
-            col.label(text="Attributes:")
-            col.prop(game, "radius")
+			col = split.column()
+			col.label(text="Attributes:")
+			col.prop(game, "radius")
 
-            col = split.column()
-            sub = col.column()
-            sub.prop(game, "use_anisotropic_friction")
-            subsub = sub.column()
-            subsub.active = game.use_anisotropic_friction
-            subsub.prop(game, "friction_coefficients", text="", slider=True)
+			col = split.column()
+			sub = col.column()
+			sub.prop(game, "use_anisotropic_friction")
+			subsub = sub.column()
+			subsub.active = game.use_anisotropic_friction
+			subsub.prop(game, "friction_coefficients", text="", slider=True)
 
-        elif physics_type == 'SENSOR':
-            col = layout.column()
-            col.prop(game, "use_actor", text="Detect Actors")
-            col.prop(ob, "hide_render", text="Invisible")
+		elif physics_type == 'SENSOR':
+			col = layout.column()
+			col.prop(game, "use_actor", text="Detect Actors")
+			col.prop(ob, "hide_render", text="Invisible")
 
-        elif physics_type in {'INVISIBLE', 'NO_COLLISION', 'OCCLUDE'}:
-            layout.prop(ob, "hide_render", text="Invisible")
+		elif physics_type in {'INVISIBLE', 'NO_COLLISION', 'OCCLUDE'}:
+			layout.prop(ob, "hide_render", text="Invisible")
 
-        elif physics_type == 'NAVMESH':
-            layout.operator("mesh.navmesh_face_copy")
-            layout.operator("mesh.navmesh_face_add")
+		elif physics_type == 'NAVMESH':
+			layout.operator("mesh.navmesh_face_copy")
+			layout.operator("mesh.navmesh_face_add")
 
-            layout.separator()
+			layout.separator()
 
-            layout.operator("mesh.navmesh_reset")
-            layout.operator("mesh.navmesh_clear")
+			layout.operator("mesh.navmesh_reset")
+			layout.operator("mesh.navmesh_clear")
 
-        if physics_type not in {'NO_COLLISION', 'OCCLUDE'}:
-            layout.separator()
-            split = layout.split()
+		if physics_type not in {'NO_COLLISION', 'OCCLUDE'}:
+			layout.separator()
+			split = layout.split()
 
-            col = split.column()
-            col.prop(game, "collision_group")
-            col = split.column()
-            col.prop(game, "collision_mask")
+			col = split.column()
+			col.prop(game, "collision_group")
+			col = split.column()
+			col.prop(game, "collision_mask")
 
 
 class PHYSICS_PT_game_collision_bounds(PhysicsButtonsPanel, Panel):
-    bl_label = "Collision Bounds"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Collision Bounds"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    @classmethod
-    def poll(cls, context):
-        game = context.object.game
-        rd = context.scene.render
-        return (game.physics_type in {'DYNAMIC', 'RIGID_BODY', 'SENSOR', 'SOFT_BODY', 'STATIC', 'CHARACTER'}) and (rd.engine in cls.COMPAT_ENGINES)
+	@classmethod
+	def poll(cls, context):
+		game = context.object.game
+		rd = context.scene.render
+		return (game.physics_type in {'DYNAMIC', 'RIGID_BODY', 'SENSOR', 'SOFT_BODY', 'STATIC', 'CHARACTER'}) and (rd.engine in cls.COMPAT_ENGINES)
 
-    def draw_header(self, context):
-        game = context.active_object.game
+	def draw_header(self, context):
+		game = context.active_object.game
 
-        self.layout.prop(game, "use_collision_bounds", text="")
+		self.layout.prop(game, "use_collision_bounds", text="")
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        game = context.active_object.game
+		game = context.active_object.game
 
-        layout.active = game.use_collision_bounds
-        layout.prop(game, "collision_bounds_type", text="Bounds")
+		layout.active = game.use_collision_bounds
+		layout.prop(game, "collision_bounds_type", text="Bounds")
 
-        row = layout.row()
-        row.prop(game, "collision_margin", text="Margin", slider=True)
-        row.prop(game, "use_collision_compound", text="Compound")
+		row = layout.row()
+		row.prop(game, "collision_margin", text="Margin", slider=True)
+		row.prop(game, "use_collision_compound", text="Compound")
 
 
 class PHYSICS_PT_game_obstacles(PhysicsButtonsPanel, Panel):
-    bl_label = "Create Obstacle"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Create Obstacle"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    @classmethod
-    def poll(cls, context):
-        game = context.object.game
-        rd = context.scene.render
-        return (game.physics_type in {'DYNAMIC', 'RIGID_BODY', 'SENSOR', 'SOFT_BODY', 'STATIC'}) and (rd.engine in cls.COMPAT_ENGINES)
+	@classmethod
+	def poll(cls, context):
+		game = context.object.game
+		rd = context.scene.render
+		return (game.physics_type in {'DYNAMIC', 'RIGID_BODY', 'SENSOR', 'SOFT_BODY', 'STATIC'}) and (rd.engine in cls.COMPAT_ENGINES)
 
-    def draw_header(self, context):
-        game = context.active_object.game
+	def draw_header(self, context):
+		game = context.active_object.game
 
-        self.layout.prop(game, "use_obstacle_create", text="")
+		self.layout.prop(game, "use_obstacle_create", text="")
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        game = context.active_object.game
+		game = context.active_object.game
 
-        layout.active = game.use_obstacle_create
+		layout.active = game.use_obstacle_create
 
-        row = layout.row()
-        row.prop(game, "obstacle_radius", text="Radius")
-        row.label()
+		row = layout.row()
+		row.prop(game, "obstacle_radius", text="Radius")
+		row.label()
 
 
 class RenderButtonsPanel():
-    bl_space_type = 'PROPERTIES'
-    bl_region_type = 'WINDOW'
-    bl_context = "render"
+	bl_space_type = 'PROPERTIES'
+	bl_region_type = 'WINDOW'
+	bl_context = "render"
 
-    @classmethod
-    def poll(cls, context):
-        rd = context.scene.render
-        return (rd.engine in cls.COMPAT_ENGINES)
+	@classmethod
+	def poll(cls, context):
+		rd = context.scene.render
+		return (rd.engine in cls.COMPAT_ENGINES)
 
 
 class RENDER_PT_embedded(RenderButtonsPanel, Panel):
-    bl_label = "Embedded Player"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Embedded Player"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        rd = context.scene.render
+		rd = context.scene.render
 
-        row = layout.row()
-        row.operator("view3d.game_start", text="Start")
-        row.label()
-        row = layout.row()
-        row.label(text="Resolution:")
-        row = layout.row(align=True)
-        row.prop(rd, "resolution_x", slider=False, text="X")
-        row.prop(rd, "resolution_y", slider=False, text="Y")
+		row = layout.row()
+		row.operator("view3d.game_start", text="Start")
+		row.label()
+		row = layout.row()
+		row.label(text="Resolution:")
+		row = layout.row(align=True)
+		row.prop(rd, "resolution_x", slider=False, text="X")
+		row.prop(rd, "resolution_y", slider=False, text="Y")
 
 
 class RENDER_PT_game_player(RenderButtonsPanel, Panel):
-    bl_label = "Standalone Player"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Standalone Player"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
+<<<<<<< .mine
+	def draw(self, context):
+		layout = self.layout
+=======
     def draw(self, context):
         import sys
         layout = self.layout
+>>>>>>> .r60397
         not_osx = sys.platform != "darwin"
 
-        gs = context.scene.game_settings
+		gs = context.scene.game_settings
 
-        row = layout.row()
-        row.operator("wm.blenderplayer_start", text="Start")
-        row.label()
+		row = layout.row()
+		row.operator("wm.blenderplayer_start", text="Start")
+		row.label()
 
+<<<<<<< .mine
+		row = layout.row()
+		row.label(text="Resolution:")
+		row = layout.row(align=True)
+		row.prop(gs, "resolution_x", slider=False, text="X")
+		row.prop(gs, "resolution_y", slider=False, text="Y")
+		row = layout.row()
+		col = row.column()
+		col.prop(gs, "show_fullscreen")
+		col = row.column()
+		col.prop(gs, "use_desktop")
+		col.active = gs.show_fullscreen
+=======
         row = layout.row()
         row.label(text="Resolution:")
         row = layout.row(align=True)
@@ -309,7 +327,16 @@
         row = layout.row()
         col = row.column()
         col.prop(gs, "show_fullscreen")
+>>>>>>> .r60397
 
+<<<<<<< .mine
+		col = layout.column()
+		col.label(text="Quality:")
+		col.prop(gs, "samples")
+		col = layout.column(align=True)
+		col.prop(gs, "depth", text="Bit Depth", slider=False)
+		col.prop(gs, "frequency", text="Refresh Rate", slider=False)
+=======
         if not_osx:
             col = row.column()
             col.prop(gs, "use_desktop")
@@ -321,432 +348,436 @@
         col = layout.column(align=True)
         col.prop(gs, "depth", text="Bit Depth", slider=False)
         col.prop(gs, "frequency", text="Refresh Rate", slider=False)
+>>>>>>> .r60397
 
 
 class RENDER_PT_game_stereo(RenderButtonsPanel, Panel):
-    bl_label = "Stereo"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Stereo"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        gs = context.scene.game_settings
-        stereo_mode = gs.stereo
+		gs = context.scene.game_settings
+		stereo_mode = gs.stereo
 
-        # stereo options:
-        layout.prop(gs, "stereo", expand=True)
+		# stereo options:
+		layout.prop(gs, "stereo", expand=True)
 
-        # stereo:
-        if stereo_mode == 'STEREO':
-            layout.prop(gs, "stereo_mode")
-            layout.prop(gs, "stereo_eye_separation")
+		# stereo:
+		if stereo_mode == 'STEREO':
+			layout.prop(gs, "stereo_mode")
+			layout.prop(gs, "stereo_eye_separation")
 
-        # dome:
-        elif stereo_mode == 'DOME':
-            layout.prop(gs, "dome_mode", text="Dome Type")
+		# dome:
+		elif stereo_mode == 'DOME':
+			layout.prop(gs, "dome_mode", text="Dome Type")
 
-            dome_type = gs.dome_mode
+			dome_type = gs.dome_mode
 
-            split = layout.split()
+			split = layout.split()
 
-            if dome_type in {'FISHEYE', 'TRUNCATED_REAR', 'TRUNCATED_FRONT'}:
-                col = split.column()
-                col.prop(gs, "dome_buffer_resolution", text="Resolution", slider=True)
-                col.prop(gs, "dome_angle", slider=True)
+			if dome_type in {'FISHEYE', 'TRUNCATED_REAR', 'TRUNCATED_FRONT'}:
+				col = split.column()
+				col.prop(gs, "dome_buffer_resolution", text="Resolution", slider=True)
+				col.prop(gs, "dome_angle", slider=True)
 
-                col = split.column()
-                col.prop(gs, "dome_tessellation", text="Tessellation")
-                col.prop(gs, "dome_tilt")
+				col = split.column()
+				col.prop(gs, "dome_tessellation", text="Tessellation")
+				col.prop(gs, "dome_tilt")
 
-            elif dome_type == 'PANORAM_SPH':
-                col = split.column()
-                col.prop(gs, "dome_buffer_resolution", text="Resolution", slider=True)
+			elif dome_type == 'PANORAM_SPH':
+				col = split.column()
+				col.prop(gs, "dome_buffer_resolution", text="Resolution", slider=True)
 
-                col = split.column()
-                col.prop(gs, "dome_tessellation", text="Tessellation")
+				col = split.column()
+				col.prop(gs, "dome_tessellation", text="Tessellation")
 
-            else:  # cube map
-                col = split.column()
-                col.prop(gs, "dome_buffer_resolution", text="Resolution", slider=True)
+			else:  # cube map
+				col = split.column()
+				col.prop(gs, "dome_buffer_resolution", text="Resolution", slider=True)
 
-                col = split.column()
+				col = split.column()
 
-            layout.prop(gs, "dome_text")
+			layout.prop(gs, "dome_text")
 
 
 class RENDER_PT_game_shading(RenderButtonsPanel, Panel):
-    bl_label = "Shading"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Shading"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        gs = context.scene.game_settings
+		gs = context.scene.game_settings
 
-        layout.prop(gs, "material_mode", expand=True)
+		layout.prop(gs, "material_mode", expand=True)
 
-        if gs.material_mode == 'GLSL':
-            split = layout.split()
+		if gs.material_mode == 'GLSL':
+			split = layout.split()
 
-            col = split.column()
-            col.prop(gs, "use_glsl_lights", text="Lights")
-            col.prop(gs, "use_glsl_shaders", text="Shaders")
-            col.prop(gs, "use_glsl_shadows", text="Shadows")
-            col.prop(gs, "use_glsl_color_management", text="Color Management")
+			col = split.column()
+			col.prop(gs, "use_glsl_lights", text="Lights")
+			col.prop(gs, "use_glsl_shaders", text="Shaders")
+			col.prop(gs, "use_glsl_shadows", text="Shadows")
+			col.prop(gs, "use_glsl_color_management", text="Color Management")
 
-            col = split.column()
-            col.prop(gs, "use_glsl_ramps", text="Ramps")
-            col.prop(gs, "use_glsl_nodes", text="Nodes")
-            col.prop(gs, "use_glsl_extra_textures", text="Extra Textures")
+			col = split.column()
+			col.prop(gs, "use_glsl_ramps", text="Ramps")
+			col.prop(gs, "use_glsl_nodes", text="Nodes")
+			col.prop(gs, "use_glsl_extra_textures", text="Extra Textures")
 
 
 class RENDER_PT_game_system(RenderButtonsPanel, Panel):
-    bl_label = "System"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "System"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        gs = context.scene.game_settings
-        col = layout.column()
-        row = col.row()
-        col = row.column()
-        col.prop(gs, "use_frame_rate")
-        col.prop(gs, "use_restrict_animation_updates")
-        col.prop(gs, "use_material_caching")
-        col = row.column()
-        col.prop(gs, "use_display_lists")
-        col.active = gs.raster_storage != 'VERTEX_BUFFER_OBJECT'
+		gs = context.scene.game_settings
+		col = layout.column()
+		row = col.row()
+		col = row.column()
+		col.prop(gs, "use_frame_rate")
+		col.prop(gs, "use_restrict_animation_updates")
+		col.prop(gs, "use_material_caching")
+		col = row.column()
+		col.prop(gs, "use_display_lists")
+		col.active = gs.raster_storage != 'VERTEX_BUFFER_OBJECT'
 
-        row = layout.row()
-        row.prop(gs, "vsync")
+		row = layout.row()
+		row.prop(gs, "vsync")
 
-        row = layout.row()
-        row.prop(gs, "raster_storage")
+		row = layout.row()
+		row.prop(gs, "raster_storage")
 
-        row = layout.row()
-        row.label("Exit Key")
-        row.prop(gs, "exit_key", text="", event=True)
+		row = layout.row()
+		row.label("Exit Key")
+		row.prop(gs, "exit_key", text="", event=True)
+		
+		row = layout.row()
+		row.prop(gs, "custom_loop")
 
 
 class RENDER_PT_game_display(RenderButtonsPanel, Panel):
-    bl_label = "Display"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Display"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        gs = context.scene.game_settings
+		gs = context.scene.game_settings
 
-        layout.prop(context.scene.render, "fps", text="Animation Frame Rate", slider=False)
+		layout.prop(context.scene.render, "fps", text="Animation Frame Rate", slider=False)
 
-        flow = layout.column_flow()
-        flow.prop(gs, "show_debug_properties", text="Debug Properties")
-        flow.prop(gs, "show_framerate_profile", text="Framerate and Profile")
-        flow.prop(gs, "show_physics_visualization", text="Physics Visualization")
-        flow.prop(gs, "use_deprecation_warnings")
-        flow.prop(gs, "show_mouse", text="Mouse Cursor")
+		flow = layout.column_flow()
+		flow.prop(gs, "show_debug_properties", text="Debug Properties")
+		flow.prop(gs, "show_framerate_profile", text="Framerate and Profile")
+		flow.prop(gs, "show_physics_visualization", text="Physics Visualization")
+		flow.prop(gs, "use_deprecation_warnings")
+		flow.prop(gs, "show_mouse", text="Mouse Cursor")
 
-        col = layout.column()
-        col.label(text="Framing:")
-        col.row().prop(gs, "frame_type", expand=True)
-        if gs.frame_type == 'LETTERBOX':
-            col.prop(gs, "frame_color", text="")
+		col = layout.column()
+		col.label(text="Framing:")
+		col.row().prop(gs, "frame_type", expand=True)
+		if gs.frame_type == 'LETTERBOX':
+			col.prop(gs, "frame_color", text="")
 
 
 class SceneButtonsPanel():
-    bl_space_type = 'PROPERTIES'
-    bl_region_type = 'WINDOW'
-    bl_context = "scene"
+	bl_space_type = 'PROPERTIES'
+	bl_region_type = 'WINDOW'
+	bl_context = "scene"
 
 
 class SCENE_PT_game_navmesh(SceneButtonsPanel, Panel):
-    bl_label = "Navigation mesh"
-    bl_options = {'DEFAULT_CLOSED'}
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Navigation mesh"
+	bl_options = {'DEFAULT_CLOSED'}
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    @classmethod
-    def poll(cls, context):
-        scene = context.scene
-        return (scene and scene.render.engine in cls.COMPAT_ENGINES)
+	@classmethod
+	def poll(cls, context):
+		scene = context.scene
+		return (scene and scene.render.engine in cls.COMPAT_ENGINES)
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        rd = context.scene.game_settings.recast_data
+		rd = context.scene.game_settings.recast_data
 
-        layout.operator("mesh.navmesh_make", text="Build navigation mesh")
+		layout.operator("mesh.navmesh_make", text="Build navigation mesh")
 
-        col = layout.column()
-        col.label(text="Rasterization:")
-        row = col.row()
-        row.prop(rd, "cell_size")
-        row.prop(rd, "cell_height")
+		col = layout.column()
+		col.label(text="Rasterization:")
+		row = col.row()
+		row.prop(rd, "cell_size")
+		row.prop(rd, "cell_height")
 
-        col = layout.column()
-        col.label(text="Agent:")
-        split = col.split()
+		col = layout.column()
+		col.label(text="Agent:")
+		split = col.split()
 
-        col = split.column()
-        col.prop(rd, "agent_height", text="Height")
-        col.prop(rd, "agent_radius", text="Radius")
+		col = split.column()
+		col.prop(rd, "agent_height", text="Height")
+		col.prop(rd, "agent_radius", text="Radius")
 
-        col = split.column()
-        col.prop(rd, "slope_max")
-        col.prop(rd, "climb_max")
+		col = split.column()
+		col.prop(rd, "slope_max")
+		col.prop(rd, "climb_max")
 
-        col = layout.column()
-        col.label(text="Region:")
-        row = col.row()
-        row.prop(rd, "region_min_size")
-        row.prop(rd, "region_merge_size")
+		col = layout.column()
+		col.label(text="Region:")
+		row = col.row()
+		row.prop(rd, "region_min_size")
+		row.prop(rd, "region_merge_size")
 
-        col = layout.column()
-        col.label(text="Polygonization:")
-        split = col.split()
+		col = layout.column()
+		col.label(text="Polygonization:")
+		split = col.split()
 
-        col = split.column()
-        col.prop(rd, "edge_max_len")
-        col.prop(rd, "edge_max_error")
+		col = split.column()
+		col.prop(rd, "edge_max_len")
+		col.prop(rd, "edge_max_error")
 
-        split.prop(rd, "verts_per_poly")
+		split.prop(rd, "verts_per_poly")
 
-        col = layout.column()
-        col.label(text="Detail Mesh:")
-        row = col.row()
-        row.prop(rd, "sample_dist")
-        row.prop(rd, "sample_max_error")
+		col = layout.column()
+		col.label(text="Detail Mesh:")
+		row = col.row()
+		row.prop(rd, "sample_dist")
+		row.prop(rd, "sample_max_error")
 
 
 class RENDER_PT_game_sound(RenderButtonsPanel, Panel):
-    bl_label = "Sound"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Sound"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        scene = context.scene
+		scene = context.scene
 
-        layout.prop(scene, "audio_distance_model")
+		layout.prop(scene, "audio_distance_model")
 
-        col = layout.column(align=True)
-        col.prop(scene, "audio_doppler_speed", text="Speed")
-        col.prop(scene, "audio_doppler_factor")
+		col = layout.column(align=True)
+		col.prop(scene, "audio_doppler_speed", text="Speed")
+		col.prop(scene, "audio_doppler_factor")
 
 
 class WorldButtonsPanel():
-    bl_space_type = 'PROPERTIES'
-    bl_region_type = 'WINDOW'
-    bl_context = "world"
+	bl_space_type = 'PROPERTIES'
+	bl_region_type = 'WINDOW'
+	bl_context = "world"
 
 
 class WORLD_PT_game_context_world(WorldButtonsPanel, Panel):
-    bl_label = ""
-    bl_options = {'HIDE_HEADER'}
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = ""
+	bl_options = {'HIDE_HEADER'}
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    @classmethod
-    def poll(cls, context):
-        rd = context.scene.render
-        return (context.scene) and (rd.use_game_engine)
+	@classmethod
+	def poll(cls, context):
+		rd = context.scene.render
+		return (context.scene) and (rd.use_game_engine)
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        scene = context.scene
-        world = context.world
-        space = context.space_data
+		scene = context.scene
+		world = context.world
+		space = context.space_data
 
-        split = layout.split(percentage=0.65)
-        if scene:
-            split.template_ID(scene, "world", new="world.new")
-        elif world:
-            split.template_ID(space, "pin_id")
+		split = layout.split(percentage=0.65)
+		if scene:
+			split.template_ID(scene, "world", new="world.new")
+		elif world:
+			split.template_ID(space, "pin_id")
 
 
 class WORLD_PT_game_world(WorldButtonsPanel, Panel):
-    bl_label = "World"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "World"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    @classmethod
-    def poll(cls, context):
-        scene = context.scene
-        return (scene.world and scene.render.engine in cls.COMPAT_ENGINES)
+	@classmethod
+	def poll(cls, context):
+		scene = context.scene
+		return (scene.world and scene.render.engine in cls.COMPAT_ENGINES)
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        world = context.world
+		world = context.world
 
-        row = layout.row()
-        row.column().prop(world, "horizon_color")
-        row.column().prop(world, "ambient_color")
+		row = layout.row()
+		row.column().prop(world, "horizon_color")
+		row.column().prop(world, "ambient_color")
 
 
 class WORLD_PT_game_mist(WorldButtonsPanel, Panel):
-    bl_label = "Mist"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Mist"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    @classmethod
-    def poll(cls, context):
-        scene = context.scene
-        return (scene.world and scene.render.engine in cls.COMPAT_ENGINES)
+	@classmethod
+	def poll(cls, context):
+		scene = context.scene
+		return (scene.world and scene.render.engine in cls.COMPAT_ENGINES)
 
-    def draw_header(self, context):
-        world = context.world
+	def draw_header(self, context):
+		world = context.world
 
-        self.layout.prop(world.mist_settings, "use_mist", text="")
+		self.layout.prop(world.mist_settings, "use_mist", text="")
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        world = context.world
+		world = context.world
 
-        layout.active = world.mist_settings.use_mist
+		layout.active = world.mist_settings.use_mist
 
-        layout.prop(world.mist_settings, "falloff")
+		layout.prop(world.mist_settings, "falloff")
 
-        row = layout.row(align=True)
-        row.prop(world.mist_settings, "start")
-        row.prop(world.mist_settings, "depth")
+		row = layout.row(align=True)
+		row.prop(world.mist_settings, "start")
+		row.prop(world.mist_settings, "depth")
 
-        layout.prop(world.mist_settings, "intensity", text="Minimum Intensity")
+		layout.prop(world.mist_settings, "intensity", text="Minimum Intensity")
 
 
 class WORLD_PT_game_physics(WorldButtonsPanel, Panel):
-    bl_label = "Physics"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Physics"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    @classmethod
-    def poll(cls, context):
-        scene = context.scene
-        return (scene.world and scene.render.engine in cls.COMPAT_ENGINES)
+	@classmethod
+	def poll(cls, context):
+		scene = context.scene
+		return (scene.world and scene.render.engine in cls.COMPAT_ENGINES)
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        gs = context.scene.game_settings
+		gs = context.scene.game_settings
 
-        layout.prop(gs, "physics_engine", text="Engine")
-        if gs.physics_engine != 'NONE':
-            layout.prop(gs, "physics_gravity", text="Gravity")
+		layout.prop(gs, "physics_engine", text="Engine")
+		if gs.physics_engine != 'NONE':
+			layout.prop(gs, "physics_gravity", text="Gravity")
 
-            split = layout.split()
+			split = layout.split()
 
-            col = split.column()
-            col.label(text="Physics Steps:")
-            sub = col.column(align=True)
-            sub.prop(gs, "physics_step_max", text="Max")
-            sub.prop(gs, "physics_step_sub", text="Substeps")
-            col.prop(gs, "fps", text="FPS")
+			col = split.column()
+			col.label(text="Physics Steps:")
+			sub = col.column(align=True)
+			sub.prop(gs, "physics_step_max", text="Max")
+			sub.prop(gs, "physics_step_sub", text="Substeps")
+			col.prop(gs, "fps", text="FPS")
 
-            col = split.column()
-            col.label(text="Logic Steps:")
-            col.prop(gs, "logic_step_max", text="Max")
+			col = split.column()
+			col.label(text="Logic Steps:")
+			col.prop(gs, "logic_step_max", text="Max")
 
-            col = layout.column()
-            col.label(text="Physics Deactivation:")
-            sub = col.row(align=True)
-            sub.prop(gs, "deactivation_linear_threshold", text="Linear Threshold")
-            sub.prop(gs, "deactivation_angular_threshold", text="Angular Threshold")
-            sub = col.row()
-            sub.prop(gs, "deactivation_time", text="Time")
+			col = layout.column()
+			col.label(text="Physics Deactivation:")
+			sub = col.row(align=True)
+			sub.prop(gs, "deactivation_linear_threshold", text="Linear Threshold")
+			sub.prop(gs, "deactivation_angular_threshold", text="Angular Threshold")
+			sub = col.row()
+			sub.prop(gs, "deactivation_time", text="Time")
 
-            col = layout.column()
-            col.prop(gs, "use_occlusion_culling", text="Occlusion Culling")
-            sub = col.column()
-            sub.active = gs.use_occlusion_culling
-            sub.prop(gs, "occlusion_culling_resolution", text="Resolution")
+			col = layout.column()
+			col.prop(gs, "use_occlusion_culling", text="Occlusion Culling")
+			sub = col.column()
+			sub.active = gs.use_occlusion_culling
+			sub.prop(gs, "occlusion_culling_resolution", text="Resolution")
 
-        else:
-            split = layout.split()
+		else:
+			split = layout.split()
 
-            col = split.column()
-            col.label(text="Physics Steps:")
-            col.prop(gs, "fps", text="FPS")
+			col = split.column()
+			col.label(text="Physics Steps:")
+			col.prop(gs, "fps", text="FPS")
 
-            col = split.column()
-            col.label(text="Logic Steps:")
-            col.prop(gs, "logic_step_max", text="Max")
+			col = split.column()
+			col.label(text="Logic Steps:")
+			col.prop(gs, "logic_step_max", text="Max")
 
 
 class WORLD_PT_game_physics_obstacles(WorldButtonsPanel, Panel):
-    bl_label = "Obstacle simulation"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Obstacle simulation"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    @classmethod
-    def poll(cls, context):
-        scene = context.scene
-        return (scene.world and scene.render.engine in cls.COMPAT_ENGINES)
+	@classmethod
+	def poll(cls, context):
+		scene = context.scene
+		return (scene.world and scene.render.engine in cls.COMPAT_ENGINES)
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        gs = context.scene.game_settings
+		gs = context.scene.game_settings
 
-        layout.prop(gs, "obstacle_simulation", text="Type")
-        if gs.obstacle_simulation != 'NONE':
-            layout.prop(gs, "level_height")
-            layout.prop(gs, "show_obstacle_simulation")
+		layout.prop(gs, "obstacle_simulation", text="Type")
+		if gs.obstacle_simulation != 'NONE':
+			layout.prop(gs, "level_height")
+			layout.prop(gs, "show_obstacle_simulation")
 
 
 class DataButtonsPanel():
-    bl_space_type = 'PROPERTIES'
-    bl_region_type = 'WINDOW'
-    bl_context = "data"
+	bl_space_type = 'PROPERTIES'
+	bl_region_type = 'WINDOW'
+	bl_context = "data"
 
 
 class DATA_PT_shadow_game(DataButtonsPanel, Panel):
-    bl_label = "Shadow"
-    COMPAT_ENGINES = {'BLENDER_GAME'}
+	bl_label = "Shadow"
+	COMPAT_ENGINES = {'BLENDER_GAME'}
 
-    @classmethod
-    def poll(cls, context):
-        COMPAT_LIGHTS = {'SPOT', 'SUN'}
-        lamp = context.lamp
-        engine = context.scene.render.engine
-        return (lamp and lamp.type in COMPAT_LIGHTS) and (engine in cls.COMPAT_ENGINES)
+	@classmethod
+	def poll(cls, context):
+		COMPAT_LIGHTS = {'SPOT', 'SUN'}
+		lamp = context.lamp
+		engine = context.scene.render.engine
+		return (lamp and lamp.type in COMPAT_LIGHTS) and (engine in cls.COMPAT_ENGINES)
 
-    def draw_header(self, context):
-        lamp = context.lamp
+	def draw_header(self, context):
+		lamp = context.lamp
 
-        self.layout.prop(lamp, "use_shadow", text="")
+		self.layout.prop(lamp, "use_shadow", text="")
 
-    def draw(self, context):
-        layout = self.layout
+	def draw(self, context):
+		layout = self.layout
 
-        lamp = context.lamp
+		lamp = context.lamp
 
-        layout.active = lamp.use_shadow
+		layout.active = lamp.use_shadow
 
-        split = layout.split()
+		split = layout.split()
 
-        col = split.column()
-        col.prop(lamp, "shadow_color", text="")
+		col = split.column()
+		col.prop(lamp, "shadow_color", text="")
 
-        col = split.column()
-        col.prop(lamp, "use_shadow_layer", text="This Layer Only")
-        col.prop(lamp, "use_only_shadow")
+		col = split.column()
+		col.prop(lamp, "use_shadow_layer", text="This Layer Only")
+		col.prop(lamp, "use_only_shadow")
 
-        col = layout.column()
-        col.label("Buffer Type:")
-        col.prop(lamp, "ge_shadow_buffer_type", text="", toggle=True)
-        col.label("Quality:")
-        col = layout.column(align=True)
-        col.prop(lamp, "shadow_buffer_size", text="Size")
-        col.prop(lamp, "shadow_buffer_bias", text="Bias")
-        col.prop(lamp, "shadow_buffer_bleed_bias", text="Bleed Bias")
+		col = layout.column()
+		col.label("Buffer Type:")
+		col.prop(lamp, "ge_shadow_buffer_type", text="", toggle=True)
+		col.label("Quality:")
+		col = layout.column(align=True)
+		col.prop(lamp, "shadow_buffer_size", text="Size")
+		col.prop(lamp, "shadow_buffer_bias", text="Bias")
+		col.prop(lamp, "shadow_buffer_bleed_bias", text="Bleed Bias")
 
-        row = layout.row()
-        row.label("Clipping:")
-        row = layout.row(align=True)
-        row.prop(lamp, "shadow_buffer_clip_start", text="Clip Start")
-        row.prop(lamp, "shadow_buffer_clip_end", text="Clip End")
+		row = layout.row()
+		row.label("Clipping:")
+		row = layout.row(align=True)
+		row.prop(lamp, "shadow_buffer_clip_start", text="Clip Start")
+		row.prop(lamp, "shadow_buffer_clip_end", text="Clip End")
 
-        if lamp.type == 'SUN':
-            row = layout.row()
-            row.prop(lamp, "shadow_frustum_size", text="Frustum Size")
+		if lamp.type == 'SUN':
+			row = layout.row()
+			row.prop(lamp, "shadow_frustum_size", text="Frustum Size")
 
 
 if __name__ == "__main__":  # only for live edit.
-    bpy.utils.register_module(__name__)
+	bpy.utils.register_module(__name__)
Index: source/blender/makesdna/DNA_scene_types.h
===================================================================
--- source/blender/makesdna/DNA_scene_types.h	(revision 60397)
+++ source/blender/makesdna/DNA_scene_types.h	(working copy)
@@ -638,6 +638,7 @@
 	float eyeseparation;
 	RecastData recastData;
 
+	char custom_loop[64];
 
 	/* physics (it was in world)*/
 	float gravity; /*Gravitation constant for the game world*/
Index: source/blender/makesrna/intern/rna_scene.c
===================================================================
--- source/blender/makesrna/intern/rna_scene.c	(revision 60397)
+++ source/blender/makesrna/intern/rna_scene.c	(working copy)
@@ -3435,6 +3435,10 @@
 	RNA_def_property_ui_text(prop, "Display Lists",
 	                         "Use display lists to speed up rendering by keeping geometry on the GPU");
 
+	prop = RNA_def_property(srna, "custom_loop", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_sdna(prop, NULL, "custom_loop");
+	RNA_def_property_ui_text(prop, "Custom gameloop class", "Filepath to custom gameloop class");
+
 	prop = RNA_def_property(srna, "use_deprecation_warnings", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_negative_sdna(prop, NULL, "flag", GAME_IGNORE_DEPRECATION_WARNINGS);
 	RNA_def_property_ui_text(prop, "Deprecation Warnings",
Index: source/gameengine/BlenderRoutines/BL_KetsjiEmbedStart.cpp
===================================================================
--- source/gameengine/BlenderRoutines/BL_KetsjiEmbedStart.cpp	(revision 60397)
+++ source/gameengine/BlenderRoutines/BL_KetsjiEmbedStart.cpp	(working copy)
@@ -55,7 +55,11 @@
 #include "KX_PythonInit.h"
 #include "KX_PyConstraintBinding.h"
 #include "KX_PythonMain.h"
+#include "KX_EngineCallbackData.h"
+#include "KX_KetsjiLogicLoop.h"
+#include "KX_PythonLogicLoop.h"
 
+
 #include "RAS_GLExtensionManager.h"
 #include "RAS_OpenGLRasterizer.h"
 #include "RAS_ListRasterizer.h"
@@ -105,58 +109,58 @@
 static BlendFileData *load_game_data(char *filename)
 {
 	ReportList reports;
-	BlendFileData *bfd;
+	BlendFileData *blend_file_data;
 	
 	BKE_reports_init(&reports, RPT_STORE);
-	bfd= BLO_read_from_file(filename, &reports);
+	blend_file_data = BLO_read_from_file(filename, &reports);
 
-	if (!bfd) {
+	if (!blend_file_data) {
 		printf("Loading %s failed: ", filename);
 		BKE_reports_print(&reports, RPT_ERROR);
 	}
 
 	BKE_reports_clear(&reports);
 
-	return bfd;
+	return blend_file_data;
 }
 
-static int BL_KetsjiNextFrame(KX_KetsjiEngine *ketsjiengine, bContext *C, wmWindow *win, Scene *scene, ARegion *ar,
-                              KX_BlenderKeyboardDevice* keyboarddevice, KX_BlenderMouseDevice* mousedevice, int draw_letterbox)
+void KX_RenderCallback(KX_EngineCallbackData *data)
 {
-	int exitrequested;
-
-	// first check if we want to exit
-	exitrequested = ketsjiengine->GetExitCode();
-
-	// kick the engine
-	bool render = ketsjiengine->NextFrame();
-
-	if (render) {
-		if (draw_letterbox) {
+	if (data->draw_letterbox) {
 			// Clear screen to border color
 			// We do this here since we set the canvas to be within the frames. This means the engine
 			// itself is unaware of the extra space, so we clear the whole region for it.
-			glClearColor(scene->gm.framing.col[0], scene->gm.framing.col[1], scene->gm.framing.col[2], 1.0f);
-			glViewport(ar->winrct.xmin, ar->winrct.ymin,
-			           BLI_rcti_size_x(&ar->winrct), BLI_rcti_size_y(&ar->winrct));
+		glClearColor(data->scene->gm.framing.col[0], 
+			data->scene->gm.framing.col[1], 
+			data->scene->gm.framing.col[2], 1.0f);
+
+		glViewport(data->ar->winrct.xmin, 
+			data->ar->winrct.ymin,
+			BLI_rcti_size_x(&data->ar->winrct), 
+			BLI_rcti_size_y(&data->ar->winrct));
+
 			glClear(GL_COLOR_BUFFER_BIT);
 		}
-
-		// render the frame
-		ketsjiengine->Render();
-	}
-
+}
+	
+void KX_EventCallback(KX_EngineCallbackData *data){
+	// test for the ESC key
+	//XXX while (qtest())
+	wmWindow *win = data->win;
+	KX_BlenderKeyboardDevice *keyboarddevice = (KX_BlenderKeyboardDevice*)data->ketsjiengine->GetKeyboardDevice();
+	KX_BlenderMouseDevice *mousedevice = (KX_BlenderMouseDevice*)data->ketsjiengine->GetMouseDevice();
+	ARegion *ar = data->ar;
+	
 	wm_window_process_events_nosleep();
 
-	// test for the ESC key
-	//XXX while (qtest())
 	while (wmEvent *event= (wmEvent *)win->queue.first) {
 		short val = 0;
 		//unsigned short event = 0; //XXX extern_qread(&val);
+		if (keyboarddevice->ConvertBlenderEvent(event->type, event->val))
+		{
+			data->ketsjiengine->RequestExit(KX_EXIT_REQUEST_BLENDER_ESC);
+		}
 
-		if (keyboarddevice->ConvertBlenderEvent(event->type,event->val))
-			exitrequested = KX_EXIT_REQUEST_BLENDER_ESC;
-
 		/* Coordinate conversion... where
 		 * should this really be?
 		 */
@@ -176,96 +180,68 @@
 		wm_event_free(event);
 	}
 
-	if (win != CTX_wm_window(C)) {
-		exitrequested= KX_EXIT_REQUEST_OUTSIDE; /* window closed while bge runs */
+	if (win != CTX_wm_window(data->C)) {
+		data->ketsjiengine->RequestExit(KX_EXIT_REQUEST_OUTSIDE); // window closed while bge runs
 	}
-	return exitrequested;
 }
 
-static struct BL_KetsjiNextFrameState {
-	class KX_KetsjiEngine* ketsjiengine;
-	struct bContext *C;
-	struct wmWindow* win;
-	struct Scene* scene;
-	struct ARegion *ar;
-	KX_BlenderKeyboardDevice* keyboarddevice;
-	KX_BlenderMouseDevice* mousedevice;
-	int draw_letterbox;
-} ketsjinextframestate;
+void setupMaterials(GlobalSettings globalsettings, KX_ISceneConverter *sceneconverter, Scene *scene)
+{
+	bool usemat, useglslmat = false;
+	if (GLEW_ARB_multitexture && GLEW_VERSION_1_1)
+		usemat = true;
+	if (GPU_glsl_support())
+		useglslmat = true;
+	else if (globalsettings.matmode == GAME_MAT_GLSL)
+		usemat = false;
 
-static int BL_KetsjiPyNextFrame(void *state0)
-{
-	BL_KetsjiNextFrameState *state = (BL_KetsjiNextFrameState *) state0;
-	return BL_KetsjiNextFrame(
-		state->ketsjiengine, 
-		state->C, 
-		state->win, 
-		state->scene, 
-		state->ar,
-		state->keyboarddevice, 
-		state->mousedevice, 
-		state->draw_letterbox);
+	if (usemat && (globalsettings.matmode != GAME_MAT_TEXFACE))
+		sceneconverter->SetMaterials(true);
+	if (useglslmat && (globalsettings.matmode == GAME_MAT_GLSL))
+		sceneconverter->SetGLSLMaterials(true);
+	if (scene->gm.flag & GAME_NO_MATERIAL_CACHING)
+		sceneconverter->SetCacheMaterials(false);
 }
 
-extern "C" void StartKetsjiShell(struct bContext *C, struct ARegion *ar, rcti *cam_frame, int always_use_expand_framing)
+BlendFileData *getBlendFileData(char *pathname, STR_String exitstring)
 {
-	/* context values */
-	struct wmWindowManager *wm= CTX_wm_manager(C);
-	struct wmWindow *win= CTX_wm_window(C);
-	struct Scene *startscene= CTX_data_scene(C);
-	struct Main* maggie1= CTX_data_main(C);
-
-
-	RAS_Rect area_rect;
-	area_rect.SetLeft(cam_frame->xmin);
-	area_rect.SetBottom(cam_frame->ymin);
-	area_rect.SetRight(cam_frame->xmax);
-	area_rect.SetTop(cam_frame->ymax);
-
-	int exitrequested = KX_EXIT_REQUEST_NO_REQUEST;
-	Main* blenderdata = maggie1;
-
-	char* startscenename = startscene->id.name+2;
-	char pathname[FILE_MAXDIR+FILE_MAXFILE], oldsce[FILE_MAXDIR+FILE_MAXFILE];
-	STR_String exitstring = "";
-	BlendFileData *bfd= NULL;
-
-	BLI_strncpy(pathname, blenderdata->name, sizeof(pathname));
-	BLI_strncpy(oldsce, G.main->name, sizeof(oldsce));
-#ifdef WITH_PYTHON
-	resetGamePythonPath(); // need this so running a second time wont use an old blendfiles path
-	setGamePythonPath(G.main->name);
-
-	// Acquire Python's GIL (global interpreter lock)
-	// so we can safely run Python code and API calls
-	PyGILState_STATE gilstate = PyGILState_Ensure();
+	char basedpath[FILE_MAX];
+	// base the actuator filename with respect
+	// to the original file working directory
+	if (exitstring != "")
+		BLI_strncpy(basedpath, exitstring.ReadPtr(), sizeof(basedpath));
 	
-	PyObject *pyGlobalDict = PyDict_New(); /* python utility storage, spans blend file loading */
-#endif
-	
-	bgl::InitExtensions(true);
+	// load relative to the last loaded file, this used to be relative
+	// to the first file but that makes no sense, relative paths in
+	// blend files should be relative to that file, not some other file
+	// that happened to be loaded first
+	BLI_path_abs(basedpath, pathname);
+	BlendFileData *blend_file_data = load_game_data(basedpath);
 
-	// VBO code for derived mesh is not compatible with BGE (couldn't find why), so disable
-	int disableVBO = (U.gameflags & USER_DISABLE_VBO);
-	U.gameflags |= USER_DISABLE_VBO;
+	// If the path didn't load, try a "relative" path
+	if (!blend_file_data)
+	{
+		// just add "//" in front of it
+		char temppath[242];
+		strcpy(temppath, "//");
+		strcat(temppath, basedpath);
+		BLI_path_abs(temppath, pathname);
+		blend_file_data = load_game_data(temppath);
+	}
+	if (!blend_file_data)
+		return NULL;
 
-	// Globals to be carried on over blender files
-	GlobalSettings gs;
-	gs.matmode= startscene->gm.matmode;
-	gs.glslflag= startscene->gm.flag;
+	return blend_file_data;
+}
 
-	do
-	{
-		View3D *v3d= CTX_wm_view3d(C);
-		RegionView3D *rv3d= CTX_wm_region_view3d(C);
-
-		// get some preferences
+KX_KetsjiEngine *setupKetsjiEngine(Scene *startscene, RAS_ICanvas *canvas, GlobalSettings *globalsettings)
+{
 		SYS_SystemHandle syshandle = SYS_GetSystem();
 		bool properties	= (SYS_GetCommandLineInt(syshandle, "show_properties", 0) != 0);
-		bool usefixed = (SYS_GetCommandLineInt(syshandle, "fixedtime", 0) != 0);
 		bool profile = (SYS_GetCommandLineInt(syshandle, "show_profile", 0) != 0);
 		bool frameRate = (SYS_GetCommandLineInt(syshandle, "show_framerate", 0) != 0);
 		bool animation_record = (SYS_GetCommandLineInt(syshandle, "animation_record", 0) != 0);
+		bool usefixed = (SYS_GetCommandLineInt(syshandle, "fixedtime", 0) != 0) && !animation_record;
 		bool displaylists = (SYS_GetCommandLineInt(syshandle, "displaylists", 0) != 0) && GPU_display_list_support();
 #ifdef WITH_PYTHON
 		bool nodepwarnings = (SYS_GetCommandLineInt(syshandle, "ignore_deprecation_warnings", 0) != 0);
@@ -274,24 +250,14 @@
 		bool mouse_state = startscene->gm.flag & GAME_SHOW_MOUSE;
 		bool restrictAnimFPS = startscene->gm.flag & GAME_RESTRICT_ANIM_UPDATES;
 
-		if (animation_record) usefixed= false; /* override since you don't want to run full-speed for sim recording */
+		// Determine user-specified mouse mode
+		RAS_ICanvas::RAS_MouseState mouse_mode = mouse_state ? RAS_ICanvas::MOUSE_NORMAL : RAS_ICanvas::MOUSE_INVISIBLE;
+		// Apply to canvas
+		canvas->SetMouseState(mouse_mode);
 
-		// create the canvas, rasterizer and rendertools
-		RAS_ICanvas* canvas = new KX_BlenderCanvas(wm, win, area_rect, ar);
-		
-		// default mouse state set on render panel
-		if (mouse_state)
-			canvas->SetMouseState(RAS_ICanvas::MOUSE_NORMAL);
-		else
-			canvas->SetMouseState(RAS_ICanvas::MOUSE_INVISIBLE);
+		int vsync_value = (startscene->gm.vsync == VSYNC_ADAPTIVE) ? -1 : startscene->gm.vsync;
+		canvas->SetSwapInterval(vsync_value); // VSYNC_OFF == 0, VSYNC_ON == 1, so this works
 
-		// Setup vsync
-		int previous_vsync = canvas->GetSwapInterval();
-		if (startscene->gm.vsync == VSYNC_ADAPTIVE)
-			canvas->SetSwapInterval(-1);
-		else
-			canvas->SetSwapInterval((startscene->gm.vsync == VSYNC_ON) ? 1 : 0);
-
 		RAS_IRenderTools* rendertools = new KX_BlenderRenderTools();
 		RAS_IRasterizer* rasterizer = NULL;
 		//Don't use displaylists with VBOs
@@ -300,10 +266,7 @@
 			rasterizer = new RAS_ListRasterizer(canvas, true, startscene->gm.raster_storage);
 		else
 			rasterizer = new RAS_OpenGLRasterizer(canvas, startscene->gm.raster_storage);
-
-		RAS_IRasterizer::MipmapOption mipmapval = rasterizer->GetMipmapping();
-
-		
+				
 		// create the inputdevices
 		KX_BlenderKeyboardDevice* keyboarddevice = new KX_BlenderKeyboardDevice();
 		KX_BlenderMouseDevice* mousedevice = new KX_BlenderMouseDevice();
@@ -312,7 +275,6 @@
 		NG_NetworkDeviceInterface* networkdevice = new
 			NG_LoopBackNetworkDeviceInterface();
 
-		//
 		// create a ketsji/blendersystem (only needed for timing and stuff)
 		KX_BlenderSystem* kxsystem = new KX_BlenderSystem();
 		
@@ -326,18 +288,166 @@
 		ketsjiengine->SetCanvas(canvas);
 		ketsjiengine->SetRenderTools(rendertools);
 		ketsjiengine->SetRasterizer(rasterizer);
+
+	// set the local settings
 		ketsjiengine->SetUseFixedTime(usefixed);
+	ketsjiengine->SetAnimRecordMode(animation_record);
 		ketsjiengine->SetTimingDisplay(frameRate, profile, properties);
 		ketsjiengine->SetRestrictAnimationFPS(restrictAnimFPS);
+
+	// set the exit key
 		KX_KetsjiEngine::SetExitKey(ConvertKeyCode(startscene->gm.exitkey));
 
-		//set the global settings (carried over if restart/load new files)
-		ketsjiengine->SetGlobalSettings(&gs);
+	// set the global settings (carried over if restart/load new files)
+	ketsjiengine->SetGlobalSettings(globalsettings);
 
+	// set the warning status for deprecated methods/accessors
 #ifdef WITH_PYTHON
 		CValue::SetDeprecationWarnings(nodepwarnings);
 #endif
 
+	return ketsjiengine;
+};
+
+void setupPythonGameloop(KX_KetsjiEngine *ketsjiengine, char *custom_loop)
+{
+	// Setup python gameloop
+
+	if (!strcmp(custom_loop, ""))
+	{
+		return;
+	}
+	// Collect the path information
+	std::vector<STR_String> path_parts = STR_String(custom_loop).Explode('.');
+
+		if (path_parts.size() < 2)
+	{
+			printf("Python class name formatting error:\n\texpected \"SomeModule.Class\", got \"%s\"\n", custom_loop);
+			return;
+	}
+
+	// Now recombine the module path (excludes the class)
+	STR_String mod_path = STR_String("");
+	char* class_string = path_parts[path_parts.size()-1].Ptr();
+	int parts_size = path_parts.size();
+	unsigned int j = 0;
+
+	for (NULL; j<parts_size-1; j++)
+			mod_path += path_parts[j];
+		if (j != parts_size - 1)
+				mod_path + ".";
+
+	// Import the module containing the path
+	PyObject* mod = PyImport_ImportModule(mod_path.Ptr());
+
+	if (mod == NULL)
+	{
+			printf("Python module not found: %s\n", mod_path.Ptr());
+			PyErr_Print();
+			return;
+	}
+
+	// Get the class object
+	PyObject* py_class = PyObject_GetAttrString(mod, class_string);
+
+	if (py_class == NULL)
+	{
+			printf("Python module found, but could not find class \"%s\"\n", class_string);
+			Py_DECREF(mod);
+			return;
+	}
+
+	// Check to make sure the object is actually a class
+	if (!PyType_Check(py_class))
+	{
+			printf("%s is not a class\n", class_string);
+			Py_DECREF(mod);
+			Py_DECREF(py_class);
+			return;
+	}
+
+	// Finally set the class
+	KX_PythonLogicLoop *loop = new KX_PythonLogicLoop(ketsjiengine);
+	loop->setPythonClass((PyTypeObject*) py_class);
+
+	// Tell engine to setup using loop (old one is deleted)
+	ketsjiengine->SetLogicLoop(loop);
+
+	Py_DECREF(mod);
+	Py_DECREF(py_class);
+}
+
+extern "C" void StartKetsjiShell(struct bContext *C, struct ARegion *ar, rcti *cam_frame, int always_use_expand_framing)
+{
+	/* context values */
+	struct wmWindowManager *wm= CTX_wm_manager(C);
+	struct wmWindow *win= CTX_wm_window(C);
+	struct Scene *startscene= CTX_data_scene(C);
+	struct Main* maggie1= CTX_data_main(C);
+
+	RAS_Rect area_rect;
+	area_rect.SetLeft(cam_frame->xmin);
+	area_rect.SetBottom(cam_frame->ymin);
+	area_rect.SetRight(cam_frame->xmax);
+	area_rect.SetTop(cam_frame->ymax);
+
+	int exitrequested = KX_EXIT_REQUEST_NO_REQUEST;
+	Main* blenderdata = maggie1;
+
+	char* startscenename = startscene->id.name+2;
+	char pathname[FILE_MAXDIR+FILE_MAXFILE], oldsce[FILE_MAXDIR+FILE_MAXFILE];
+	STR_String exitstring = "";
+	BlendFileData *blend_file_data= NULL;
+
+	BLI_strncpy(pathname, blenderdata->name, sizeof(pathname));
+	BLI_strncpy(oldsce, G.main->name, sizeof(oldsce));
+
+#ifdef WITH_PYTHON
+	resetGamePythonPath(); // need this so running a second time wont use an old blendfiles path
+	setGamePythonPath(G.main->name);
+
+	// Acquire Python's GIL (global interpreter lock)
+	// so we can safely run Python code and API calls
+	PyGILState_STATE gilstate = PyGILState_Ensure();
+	
+	PyObject *pyGlobalDict = PyDict_New(); /* python utility storage, spans blend file loading */
+#endif
+	
+	bgl::InitExtensions(true);
+
+	// VBO code for derived mesh is not compatible with BGE (couldn't find why), so disable
+	int disableVBO = (U.gameflags & USER_DISABLE_VBO);
+	U.gameflags |= USER_DISABLE_VBO;
+
+	// Globals to be carried on over blender files
+	GlobalSettings gs;
+	gs.matmode= startscene->gm.matmode;
+	gs.glslflag= startscene->gm.flag;
+				
+	// Create callbacks for render setup and event setup pre engine
+	KX_EngineCallbackData *callbacks = new KX_EngineCallbackData();
+
+	// User defined Python gameloop path
+	char *custom_loop = startscene->gm.custom_loop;
+
+	do
+	{
+		View3D *v3d= CTX_wm_view3d(C);
+		RegionView3D *rv3d= CTX_wm_region_view3d(C);
+
+		// Create the canvas
+		RAS_ICanvas* canvas = new KX_BlenderCanvas(wm, win, area_rect, ar);
+
+		// Setup vsync
+		int previous_vsync = canvas->GetSwapInterval();
+
+		// Create the engine
+		KX_KetsjiEngine *ketsjiengine = setupKetsjiEngine(startscene, canvas, &gs);
+			
+		// Get the rasterizer (from engine creation call)
+		RAS_IRasterizer *rasterizer = ketsjiengine->GetRasterizer();
+		RAS_IRasterizer::MipmapOption mipmapval = rasterizer->GetMipmapping();
+
 		//lock frame and camera enabled - storing global values
 		int tmp_lay= startscene->lay;
 		Object *tmp_camera = startscene->camera;
@@ -348,7 +458,7 @@
 		}
 
 		// some blender stuff
-		float camzoom;
+		float camzoom = 2.0;
 		int draw_letterbox = 0;
 		
 		if (rv3d->persp==RV3D_CAMOB) {
@@ -356,15 +466,11 @@
 				camzoom = 1.0f;
 				draw_letterbox = 1;
 			}
-			else {
+			else
 				camzoom = 1.0f / BKE_screen_view3d_zoom_to_fac(rv3d->camzoom);
 			}
-		}
-		else {
-			camzoom = 2.0;
-		}
 
-
+		// Set the drawing type from the 3D viewport
 		ketsjiengine->SetDrawType(v3d->drawtype);
 		ketsjiengine->SetCameraZoom(camzoom);
 		
@@ -372,38 +478,18 @@
 		if (exitrequested == KX_EXIT_REQUEST_START_OTHER_GAME || exitrequested == KX_EXIT_REQUEST_RESTART_GAME)
 		{
 			exitrequested = KX_EXIT_REQUEST_NO_REQUEST;
-			if (bfd) BLO_blendfiledata_free(bfd);
-			
-			char basedpath[FILE_MAX];
-			// base the actuator filename with respect
-			// to the original file working directory
 
-			if (exitstring != "")
-				BLI_strncpy(basedpath, exitstring.ReadPtr(), sizeof(basedpath));
-
-			// load relative to the last loaded file, this used to be relative
-			// to the first file but that makes no sense, relative paths in
-			// blend files should be relative to that file, not some other file
-			// that happened to be loaded first
-			BLI_path_abs(basedpath, pathname);
-			bfd = load_game_data(basedpath);
+			if (blend_file_data) 
+				BLO_blendfiledata_free(blend_file_data);
 			
-			// if it wasn't loaded, try it forced relative
-			if (!bfd)
-			{
-				// just add "//" in front of it
-				char temppath[FILE_MAX] = "//";
-				BLI_strncpy(temppath + 2, basedpath, FILE_MAX - 2);
+			// Get the blend file data from path
+			blend_file_data = getBlendFileData(pathname, exitstring);
 				
-				BLI_path_abs(temppath, pathname);
-				bfd = load_game_data(temppath);
-			}
-			
 			// if we got a loaded blendfile, proceed
-			if (bfd)
+			if (blend_file_data)
 			{
-				blenderdata = bfd->main;
-				startscenename = bfd->curscene->id.name + 2;
+				blenderdata = blend_file_data->main;
+				startscenename = blend_file_data->curscene->id.name + 2;
 
 				if (blenderdata) {
 					BLI_strncpy(G.main->name, blenderdata->name, sizeof(G.main->name));
@@ -413,28 +499,30 @@
 #endif
 				}
 			}
-			// else forget it, we can't find it
+			// Else we cannot do anything, so exit!
 			else
-			{
 				exitrequested = KX_EXIT_REQUEST_QUIT_GAME;
 			}
-		}
 
-		Scene *scene= bfd ? bfd->curscene : (Scene *)BLI_findstring(&blenderdata->scene, startscenename, offsetof(ID, name) + 2);
+		// Get a scene to start with
+		Scene *scene = blend_file_data ? blend_file_data->curscene : (Scene *)BLI_findstring(&blenderdata->scene, startscenename, offsetof(ID, name) + 2);
 
+		// If it exists, setup scene
 		if (scene)
 		{
-			int startFrame = scene->r.cfra;
-			ketsjiengine->SetAnimRecordMode(animation_record, startFrame);
-			
+			// Start animation recording from scene's current frame (if enabled)
+			ketsjiengine->SetAnimationFrame(scene->r.cfra);
+
+			// Setup stero rendering if enabled
+			if (scene->gm.stereoflag == STEREO_ENABLED) {
 			// Quad buffered needs a special window.
-			if (scene->gm.stereoflag == STEREO_ENABLED) {
 				if (scene->gm.stereomode != RAS_IRasterizer::RAS_STEREO_QUADBUFFERED)
 					rasterizer->SetStereoMode((RAS_IRasterizer::StereoMode) scene->gm.stereomode);
-
+				// Setup stereo eye separation
 				rasterizer->SetEyeSeparation(scene->gm.eyeseparation);
 			}
 
+			// Set background color of window from scene
 			rasterizer->SetBackColor(scene->gm.framing.col[0], scene->gm.framing.col[1], scene->gm.framing.col[2], 0.0f);
 		}
 		
@@ -446,52 +534,35 @@
 				ketsjiengine->SetCameraOverrideUseOrtho((rv3d->persp == RV3D_ORTHO));
 				ketsjiengine->SetCameraOverrideProjectionMatrix(MT_CmMatrix4x4(rv3d->winmat));
 				ketsjiengine->SetCameraOverrideViewMatrix(MT_CmMatrix4x4(rv3d->viewmat));
-				if (rv3d->persp == RV3D_ORTHO)
-				{
 					ketsjiengine->SetCameraOverrideClipping(v3d->near, v3d->far);
-				}
-				else
-				{
-					ketsjiengine->SetCameraOverrideClipping(v3d->near, v3d->far);
-				}
 				ketsjiengine->SetCameraOverrideLens(v3d->lens);
 			}
 			
-			// create a scene converter, create and convert the startingscene
+			// Create the scene converter
 			KX_ISceneConverter* sceneconverter = new KX_BlenderSceneConverter(blenderdata, ketsjiengine);
+
+			// Set the scene converter
 			ketsjiengine->SetSceneConverter(sceneconverter);
-			sceneconverter->addInitFromFrame=false;
+			sceneconverter->addInitFromFrame = false;
+
 			if (always_use_expand_framing)
 				sceneconverter->SetAlwaysUseExpandFraming(true);
 
-			bool usemat = false, useglslmat = false;
-
-			if (GLEW_ARB_multitexture && GLEW_VERSION_1_1)
-				usemat = true;
-
-			if (GPU_glsl_support())
-				useglslmat = true;
-			else if (gs.matmode == GAME_MAT_GLSL)
-				usemat = false;
-
-			if (usemat && (gs.matmode != GAME_MAT_TEXFACE))
-				sceneconverter->SetMaterials(true);
-			if (useglslmat && (gs.matmode == GAME_MAT_GLSL))
-				sceneconverter->SetGLSLMaterials(true);
-			if (scene->gm.flag & GAME_NO_MATERIAL_CACHING)
-				sceneconverter->SetCacheMaterials(false);
+			// Setup the materials for the sceneconverter
+			setupMaterials(gs, sceneconverter, scene);
 					
-			KX_Scene* startscene = new KX_Scene(keyboarddevice,
-				mousedevice,
-				networkdevice,
-				startscenename,
-				scene,
-				canvas);
+			// Create the initial scene
+			KX_Scene* startscene = new KX_Scene(ketsjiengine->GetKeyboardDevice(), ketsjiengine->GetMouseDevice(),
+												ketsjiengine->GetNetworkDevice(), startscenename, scene, canvas);
 
 #ifdef WITH_PYTHON
-			// some python things
+			// Create namespaces
 			PyObject *gameLogic, *gameLogic_keys;
+			// Setup Python API imports
 			setupGamePython(ketsjiengine, startscene, blenderdata, pyGlobalDict, &gameLogic, &gameLogic_keys, 0, NULL);
+			// Setup GameLoop from Python
+			setupPythonGameloop(ketsjiengine, custom_loop);
+			
 #endif // WITH_PYTHON
 
 			//initialize Dome Settings
@@ -513,13 +584,11 @@
 			if (blenderdata->versionfile < 250)
 				do_versions_ipos_to_animato(blenderdata);
 
+			// Convert starting scene
 			if (sceneconverter)
 			{
 				// convert and add scene
-				sceneconverter->ConvertScene(
-					startscene,
-					rendertools,
-					canvas);
+				sceneconverter->ConvertScene(startscene, ketsjiengine->GetRenderTools(), canvas);
 				ketsjiengine->AddScene(startscene);
 				
 				// init the rasterizer
@@ -527,88 +596,68 @@
 				
 				// start the engine
 				ketsjiengine->StartEngine(true);
-				
 
 				// Set the animation playback rate for ipo's and actions
 				// the framerate below should patch with FPS macro defined in blendef.h
 				// Could be in StartEngine set the framerate, we need the scene to do this
 				ketsjiengine->SetAnimFrameRate(FPS);
-				
-#ifdef WITH_PYTHON
-				char *python_main = NULL;
-				pynextframestate.state = NULL;
-				pynextframestate.func = NULL;
-				python_main = KX_GetPythonMain(scene);
+				//exitrequested = BL_KetsjiNextFrame(ketsjiengine, C, win, scene, ar, keyboarddevice, mousedevice, draw_letterbox);
 
-				// the mainloop
+				callbacks->C = C;
+				callbacks->win = win;
+				callbacks->scene = scene;
+				callbacks->ar = ar;
+				callbacks->draw_letterbox = draw_letterbox;
+				callbacks->rendercallback = KX_RenderCallback;
+				callbacks->eventcallback = KX_EventCallback;
+				callbacks->ketsjiengine = ketsjiengine;
+
+				// Pass callbacks to refresh display, events
+				ketsjiengine->SetEngineCallbacks(callbacks);
+
+				// Starting gameloop
 				printf("\nBlender Game Engine Started\n");
-				if (python_main) {
-					char *python_code = KX_GetPythonCode(blenderdata, python_main);
-					if (python_code) {
-						ketsjinextframestate.ketsjiengine = ketsjiengine;
-						ketsjinextframestate.C = C;
-						ketsjinextframestate.win = win;
-						ketsjinextframestate.scene = scene;
-						ketsjinextframestate.ar = ar;
-						ketsjinextframestate.keyboarddevice = keyboarddevice;
-						ketsjinextframestate.mousedevice = mousedevice;
-						ketsjinextframestate.draw_letterbox = draw_letterbox;
-			
-						pynextframestate.state = &ketsjinextframestate;
-						pynextframestate.func = &BL_KetsjiPyNextFrame;
-						printf("Yielding control to Python script '%s'...\n", python_main);
-						PyRun_SimpleString(python_code);
-						printf("Exit Python script '%s'\n", python_main);
-						MEM_freeN(python_code);
-					}
-				}
-				else
-#endif  /* WITH_PYTHON */
-				{
-					while (!exitrequested)
-					{
-						exitrequested = BL_KetsjiNextFrame(ketsjiengine, C, win, scene, ar, keyboarddevice, mousedevice, draw_letterbox);
-					}
-				}
+
+				// Allow engine to run loop
+				KX_KetsjiLogicLoop *loop = ketsjiengine->GetLogicLoop();
+				loop->GiveHandle();
+				loop = NULL;
+
+				// Gameloop now exiting
 				printf("Blender Game Engine Finished\n");
+
+				// Get exit data
 				exitstring = ketsjiengine->GetExitString();
-#ifdef WITH_PYTHON
-				if (python_main) MEM_freeN(python_main);
-#endif  /* WITH_PYTHON */
+				exitrequested = ketsjiengine->GetExitCode();
 
 				gs = *(ketsjiengine->GetGlobalSettings());
 
-				// when exiting the mainloop
 #ifdef WITH_PYTHON
-				// Clears the dictionary by hand:
-				// This prevents, extra references to global variables
-				// inside the GameLogic dictionary when the python interpreter is finalized.
-				// which allows the scene to safely delete them :)
-				// see: (space.c)->start_game
+				/* Clears the dictionary by hand:
+				This prevents, extra references to global variables	inside the
+				GameLogic dictionary when the python interpreter is finalized.
+				This allows the scene to safely delete them; see (space.c)->start_game
+				PyDict_Clear(PyModule_GetDict(gameLogic)); */
 				
-				//PyDict_Clear(PyModule_GetDict(gameLogic));
+				// Keep original items, means python plugins will autocomplete members
+				PyObject *new_gameLogic_keys = PyDict_Keys(PyModule_GetDict(gameLogic));
+				const Py_ssize_t numitems= PyList_GET_SIZE(new_gameLogic_keys);
 				
-				// Keep original items, means python plugins will autocomplete members
-				PyObject *gameLogic_keys_new = PyDict_Keys(PyModule_GetDict(gameLogic));
-				const Py_ssize_t numitems= PyList_GET_SIZE(gameLogic_keys_new);
-				Py_ssize_t listIndex;
-				for (listIndex=0; listIndex < numitems; listIndex++) {
-					PyObject *item = PyList_GET_ITEM(gameLogic_keys_new, listIndex);
+				for (Py_ssize_t index=0; index < numitems; index++) {
+					PyObject *item = PyList_GET_ITEM(new_gameLogic_keys, index);
+
 					if (!PySequence_Contains(gameLogic_keys, item)) {
-						PyDict_DelItem(	PyModule_GetDict(gameLogic), item);
+						PyDict_DelItem(PyModule_GetDict(gameLogic), item);
 					}
 				}
-				Py_DECREF(gameLogic_keys_new);
-				gameLogic_keys_new = NULL;
+
+				Py_DECREF(new_gameLogic_keys);
+				new_gameLogic_keys = NULL;
 #endif
 				ketsjiengine->StopEngine();
 #ifdef WITH_PYTHON
 				exitGamePythonScripting();
 #endif
-				networkdevice->Disconnect();
-			}
-			if (sceneconverter)
-			{
 				delete sceneconverter;
 				sceneconverter = NULL;
 			}
@@ -624,6 +673,7 @@
 			startscene->camera= tmp_camera;
 		}
 
+		// Reset mouse state
 		if (exitrequested != KX_EXIT_REQUEST_OUTSIDE)
 		{
 			// set the cursor back to normal
@@ -639,36 +689,15 @@
 			delete ketsjiengine;
 			ketsjiengine = NULL;
 		}
-		if (kxsystem)
+		if (callbacks)
 		{
-			delete kxsystem;
-			kxsystem = NULL;
+			delete callbacks;
+			callbacks = NULL;
 		}
-		if (networkdevice)
-		{
-			delete networkdevice;
-			networkdevice = NULL;
-		}
-		if (keyboarddevice)
-		{
-			delete keyboarddevice;
-			keyboarddevice = NULL;
-		}
-		if (mousedevice)
-		{
-			delete mousedevice;
-			mousedevice = NULL;
-		}
 		if (rasterizer)
 		{
-			delete rasterizer;
 			rasterizer = NULL;
 		}
-		if (rendertools)
-		{
-			delete rendertools;
-			rendertools = NULL;
-		}
 		if (canvas)
 		{
 			canvas->SetSwapInterval(previous_vsync); // Set the swap interval back
@@ -684,11 +713,13 @@
 	if (!disableVBO)
 		U.gameflags &= ~USER_DISABLE_VBO;
 
-	if (bfd) BLO_blendfiledata_free(bfd);
+	if (blend_file_data) 
+		BLO_blendfiledata_free(blend_file_data);
 
 	BLI_strncpy(G.main->name, oldsce, sizeof(G.main->name));
 
 #ifdef WITH_PYTHON
+	// Decrement the globalDict reference
 	Py_DECREF(pyGlobalDict);
 
 	// Release Python's GIL
Index: source/gameengine/Converter/BL_BlenderDataConversion.cpp
===================================================================
--- source/gameengine/Converter/BL_BlenderDataConversion.cpp	(revision 60397)
+++ source/gameengine/Converter/BL_BlenderDataConversion.cpp	(working copy)
@@ -1592,22 +1592,58 @@
 	//int userigidbody = SYS_GetCommandLineInt(syshandle,"norigidbody",0);
 	//bool bRigidBody = (userigidbody == 0);
 
+	bool dynamic = (blenderobject->gameflag & OB_DYNAMIC) != 0;
+	bool actor = (blenderobject->gameflag & OB_ACTOR)!=0;
+	bool softbody = (blenderobject->gameflag & OB_SOFT_BODY) != 0;
+	bool rigidbody = (blenderobject->gameflag & OB_RIGID_BODY) != 0;
+	bool character = (blenderobject->gameflag & OB_CHARACTER) != 0;
+	bool navmesh = (blenderobject->gameflag & OB_NAVMESH) != 0;
+	bool sensor = (blenderobject->gameflag & OB_SENSOR) != 0;
+	bool ghost = (blenderobject->gameflag & OB_GHOST) != 0;
+	bool collision = (blenderobject->gameflag & OB_COLLISION) !=0;
+	bool occluder = (blenderobject->gameflag & OB_OCCLUDER) != 0;
+
+	gameobj->m_physicsActor = actor;
+
 	// object has physics representation?
-	if (!(blenderobject->gameflag & OB_COLLISION)) {
+	if (!collision) {
+
 		// Respond to all collisions so that Near sensors work on No Collision
 		// objects.
 		gameobj->SetUserCollisionGroup(0xff);
 		gameobj->SetUserCollisionMask(0xff);
+
+		// Non collider Enumes (ghost objects are still handled by collisions)
+		if (navmesh)
+			gameobj->m_physicsType = KX_GameObject::NAVIGATION_MESH;
+
+		else if (occluder)
+			gameobj->m_physicsType = KX_GameObject::OCCLUDER;
+
 		return;
 	}
 
+	// Set m_physicsType enum to read in game
+	if (softbody)
+		gameobj->m_physicsType = KX_GameObject::SOFT_BODY;
+	else if (character)
+		gameobj->m_physicsType = KX_GameObject::CHARACTER;
+	else if (rigidbody)
+		gameobj->m_physicsType = KX_GameObject::RIGID_BODY;
+	else if (dynamic)
+		gameobj->m_physicsType = KX_GameObject::DYNAMIC;
+	else if (sensor)
+		gameobj->m_physicsType = KX_GameObject::SENSOR;
+	else
+		gameobj->m_physicsType = KX_GameObject::STATIC;
+
 	gameobj->SetUserCollisionGroup(blenderobject->col_group);
 	gameobj->SetUserCollisionMask(blenderobject->col_mask);
 
 	// get Root Parent of blenderobject
 	struct Object* parent= blenderobject->parent;
 	while (parent && parent->parent) {
-		parent= parent->parent;
+		parent = parent->parent;
 	}
 
 	bool isCompoundChild = false;
@@ -1646,11 +1682,13 @@
 	objprop.m_margin = blenderobject->margin;
 	
 	// ACTOR is now a separate feature
-	objprop.m_isactor = (blenderobject->gameflag & OB_ACTOR)!=0;
-	objprop.m_dyna = (blenderobject->gameflag & OB_DYNAMIC) != 0;
-	objprop.m_softbody = (blenderobject->gameflag & OB_SOFT_BODY) != 0;
-	objprop.m_angular_rigidbody = (blenderobject->gameflag & OB_RIGID_BODY) != 0;
-	objprop.m_character = (blenderobject->gameflag & OB_CHARACTER) != 0;
+	objprop.m_isactor = actor;
+	objprop.m_dyna = dynamic;
+	objprop.m_softbody = softbody;
+	objprop.m_angular_rigidbody = rigidbody;
+	objprop.m_character = character;
+	objprop.m_sensor = sensor;
+	objprop.m_ghost = ghost;
 	
 	///contact processing threshold is only for rigid bodies and static geometry, not 'dynamic'
 	if (objprop.m_angular_rigidbody || !objprop.m_dyna )
@@ -1660,10 +1698,8 @@
 	{
 		objprop.m_contactProcessingThreshold = 0.f;
 	}
-
-	objprop.m_sensor = (blenderobject->gameflag & OB_SENSOR) != 0;
 	
-	if (objprop.m_softbody)
+	if (softbody)
 	{
 		///for game soft bodies
 		if (blenderobject->bsoft)
@@ -1752,7 +1788,6 @@
 		}
 	}
 
-	objprop.m_ghost = (blenderobject->gameflag & OB_GHOST) != 0;
 	objprop.m_disableSleeping = (blenderobject->gameflag & OB_COLLISION_RESPONSE) != 0;//abuse the OB_COLLISION_RESPONSE flag
 	//mmm, for now, taks this for the size of the dynamicobject
 	// Blender uses inertia for radius of dynamic object
@@ -1762,12 +1797,12 @@
 	objprop.m_isdeformable = ((blenderobject->gameflag2 & 2)) != 0;
 	objprop.m_boundclass = objprop.m_dyna?KX_BOUNDSPHERE:KX_BOUNDMESH;
 	
-	if ((blenderobject->gameflag & OB_SOFT_BODY) && !(blenderobject->gameflag & OB_BOUNDS))
+	if (softbody && !(blenderobject->gameflag & OB_BOUNDS))
 	{
 		objprop.m_boundclass = KX_BOUNDMESH;
 	}
 
-	if ((blenderobject->gameflag & OB_CHARACTER) && !(blenderobject->gameflag & OB_BOUNDS))
+	if (character && !(blenderobject->gameflag & OB_BOUNDS))
 	{
 		objprop.m_boundclass = KX_BOUNDSPHERE;
 	}
@@ -1842,8 +1877,8 @@
 		KX_GameObject *parentgameobject = converter->FindGameObject(parent);
 		objprop.m_dynamic_parent = parentgameobject;
 		//cannot be dynamic:
-		objprop.m_dyna = false;
-		objprop.m_softbody = false;
+		objprop.m_dyna = dynamic = false;
+		objprop.m_softbody = softbody = false;
 		shapeprops->m_mass = 0.f;
 	}
 
Index: source/gameengine/GameLogic/SCA_IScene.h
===================================================================
--- source/gameengine/GameLogic/SCA_IScene.h	(revision 60397)
+++ source/gameengine/GameLogic/SCA_IScene.h	(working copy)
@@ -36,6 +36,7 @@
 
 #include "STR_String.h"
 #include "RAS_2DFilterManager.h"
+#include "MT_Matrix4x4.h"
 
 #ifdef WITH_CXX_GUARDEDALLOC
 #include "MEM_guardedalloc.h"
@@ -58,7 +59,8 @@
 	SCA_IScene();
 	virtual ~SCA_IScene();
 	virtual class SCA_IObject* AddReplicaObject(class CValue* gameobj,
-												class CValue* locationobj,
+											  MT_Matrix4x4 temp,
+											  int layer,
 												int lifespan=0)=0;
 	virtual void	RemoveObject(class CValue* gameobj)=0;
 	virtual void	DelayedRemoveObject(class CValue* gameobj)=0;
Index: source/gameengine/GameLogic/SCA_LogicManager.cpp
===================================================================
--- source/gameengine/GameLogic/SCA_LogicManager.cpp	(revision 60397)
+++ source/gameengine/GameLogic/SCA_LogicManager.cpp	(working copy)
@@ -119,6 +119,14 @@
 CValue* SCA_LogicManager::GetGameObjectByName(const STR_String& gameobjname)
 {
 	STR_HashedString mn = gameobjname;
+
+	int total = m_mapStringToGameObjects.size();
+
+	for (int i=0; i < total; i++)
+	{
+		CValue** gam = m_mapStringToGameObjects.at(i);
+	}
+
 	CValue** gameptr = m_mapStringToGameObjects[mn];
 	
 	if (gameptr)
Index: source/gameengine/GameLogic/SCA_PythonMouse.cpp
===================================================================
--- source/gameengine/GameLogic/SCA_PythonMouse.cpp	(revision 60397)
+++ source/gameengine/GameLogic/SCA_PythonMouse.cpp	(working copy)
@@ -87,6 +87,7 @@
 PyAttributeDef SCA_PythonMouse::Attributes[] = {
 	KX_PYATTRIBUTE_RO_FUNCTION("events", SCA_PythonMouse, pyattr_get_events),
 	KX_PYATTRIBUTE_RO_FUNCTION("active_events", SCA_PythonMouse, pyattr_get_active_events),
+	KX_PYATTRIBUTE_RO_FUNCTION("screen_center", SCA_PythonMouse, pyattr_get_screen_center),
 	KX_PYATTRIBUTE_RW_FUNCTION("position", SCA_PythonMouse, pyattr_get_position, pyattr_set_position),
 	KX_PYATTRIBUTE_RW_FUNCTION("visible", SCA_PythonMouse, pyattr_get_visible, pyattr_set_visible),
 	{ NULL }	//Sentinel
@@ -123,6 +124,27 @@
 	return self->m_event_dict;
 }
 
+PyObject *SCA_PythonMouse::pyattr_get_screen_center(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef)
+{
+	SCA_PythonMouse* self = static_cast<SCA_PythonMouse*>(self_v);
+
+	float x_coord, y_coord;
+	int x, y;
+
+	x = (int)(0.5 * self->m_canvas->GetWidth());
+	y = (int)(0.5 * self->m_canvas->GetHeight());
+
+	x_coord = self->m_canvas->GetMouseNormalizedX(x);
+	y_coord = self->m_canvas->GetMouseNormalizedY(y);
+
+	PyObject *ret = PyTuple_New(2);
+
+	PyTuple_SET_ITEM(ret, 0, PyFloat_FromDouble(x_coord));
+	PyTuple_SET_ITEM(ret, 1, PyFloat_FromDouble(y_coord));
+
+	return ret;
+}
+
 PyObject *SCA_PythonMouse::pyattr_get_position(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef)
 {
 	SCA_PythonMouse* self = static_cast<SCA_PythonMouse*>(self_v);
Index: source/gameengine/GameLogic/SCA_PythonMouse.h
===================================================================
--- source/gameengine/GameLogic/SCA_PythonMouse.h	(revision 60397)
+++ source/gameengine/GameLogic/SCA_PythonMouse.h	(working copy)
@@ -49,6 +49,7 @@
 
 	static PyObject *pyattr_get_events(void* self_v, const KX_PYATTRIBUTE_DEF *attrdef);
 	static PyObject *pyattr_get_active_events(void* self_v, const KX_PYATTRIBUTE_DEF *attrdef);
+	static PyObject *pyattr_get_screen_center(void* self_v, const KX_PYATTRIBUTE_DEF *attrdef);
 	static PyObject *pyattr_get_position(void* self_v, const KX_PYATTRIBUTE_DEF *attrdef);
 	static int       pyattr_set_position(void* self_v, const KX_PYATTRIBUTE_DEF *attrdef, PyObject *value);
 	static PyObject *pyattr_get_visible(void* self_v, const KX_PYATTRIBUTE_DEF *attrdef);
Index: source/gameengine/Ketsji/KX_Camera.cpp
===================================================================
--- source/gameengine/Ketsji/KX_Camera.cpp	(revision 60397)
+++ source/gameengine/Ketsji/KX_Camera.cpp	(working copy)
@@ -144,6 +144,12 @@
 }
 
 
+void KX_Camera::UpdateModelviewMatrix()
+{
+	MT_Transform camtrans(GetWorldToCamera());
+	MT_Matrix4x4 viewmat(camtrans);
+	SetModelviewMatrix(viewmat);
+}
 
 /**
  * Sets the modelview matrix that is used by the rasterizer.
@@ -594,6 +600,8 @@
 		MT_Point3 center;
 		if (PyVecTo(pycenter, center))
 		{
+	
+			UpdateModelviewMatrix();
 			return PyLong_FromLong(SphereInsideFrustum(center, radius)); /* new ref */
 		}
 	}
@@ -645,6 +653,8 @@
 			return NULL;
 	}
 	
+	UpdateModelviewMatrix();
+
 	return PyLong_FromLong(BoxInsideFrustum(box)); /* new ref */
 }
 
@@ -665,6 +675,9 @@
 )
 {
 	MT_Point3 point;
+	
+	UpdateModelviewMatrix();
+
 	if (PyVecTo(value, point))
 	{
 		return PyLong_FromLong(PointInsideFrustum(point)); /* new ref */
@@ -882,6 +895,7 @@
 PyObject *KX_Camera::pyattr_get_modelview_matrix(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef)
 {
 	KX_Camera* self = static_cast<KX_Camera*>(self_v);
+	self->UpdateModelviewMatrix();
 	return PyObjectFrom(self->GetModelviewMatrix()); 
 }
 
@@ -991,6 +1005,8 @@
 	GLdouble modelmatrix[16];
 	GLdouble projmatrix[16];
 
+	this->UpdateModelviewMatrix();
+
 	MT_Matrix4x4 m_modelmatrix = this->GetModelviewMatrix();
 	MT_Matrix4x4 m_projmatrix = this->GetProjectionMatrix();
 
@@ -1034,6 +1050,8 @@
 	GLdouble modelmatrix[16];
 	GLdouble projmatrix[16];
 
+	this->UpdateModelviewMatrix();
+
 	MT_Matrix4x4 m_modelmatrix = this->GetModelviewMatrix();
 	MT_Matrix4x4 m_projmatrix = this->GetProjectionMatrix();
 
Index: source/gameengine/Ketsji/KX_Camera.h
===================================================================
--- source/gameengine/Ketsji/KX_Camera.h	(revision 60397)
+++ source/gameengine/Ketsji/KX_Camera.h	(working copy)
@@ -164,6 +164,8 @@
 	MT_Transform		GetWorldToCamera() const;
 	MT_Transform		GetCameraToWorld() const;
 
+	void				UpdateModelviewMatrix();
+
 	/**
 	 * Not implemented.
 	 */
Index: source/gameengine/Ketsji/KX_EngineCallbackData.h
===================================================================
--- source/gameengine/Ketsji/KX_EngineCallbackData.h	(revision 0)
+++ source/gameengine/Ketsji/KX_EngineCallbackData.h	(working copy)
@@ -0,0 +1,15 @@
+#ifndef __KX_ENGINECALLBACKDATA_H__
+#define __KX_ENGINECALLBACKDATA_H__
+
+struct KX_EngineCallbackData {
+
+	class KX_KetsjiEngine* ketsjiengine;
+	struct bContext *C;
+	struct wmWindow* win;
+	struct Scene* scene;
+	struct ARegion *ar;
+	int draw_letterbox;
+	void (*rendercallback)(KX_EngineCallbackData *data);
+	void (*eventcallback)(KX_EngineCallbackData *data);
+};
+#endif
\ No newline at end of file
Index: source/gameengine/Ketsji/KX_GameObject.cpp
===================================================================
--- source/gameengine/Ketsji/KX_GameObject.cpp	(revision 60397)
+++ source/gameengine/Ketsji/KX_GameObject.cpp	(working copy)
@@ -57,6 +57,7 @@
 #include "SG_Controller.h"
 #include "KX_IPhysicsController.h"
 #include "PHY_IGraphicController.h"
+#include "PHY_DynamicTypes.h"
 #include "SG_Node.h"
 #include "SG_Controller.h"
 #include "KX_ClientObjectInfo.h"
@@ -113,11 +114,19 @@
       m_pInstanceObjects(NULL),
       m_pDupliGroupObject(NULL),
       m_actionManager(NULL),
-      m_isDeformable(false)
+      m_isDeformable(false),
+	  m_physicsType(NO_COLLISION),
+	  m_physicsActor(false)
 
+
 #ifdef WITH_PYTHON
+<<<<<<< .mine
     , m_attr_dict(NULL),
+	m_collisionCallbacks(NULL)
+=======
+    , m_attr_dict(NULL),
     m_collisionCallbacks(NULL)
+>>>>>>> .r60397
 #endif
 {
 	m_ignore_activity_culling = false;
@@ -196,6 +205,22 @@
 	{
 		m_pInstanceObjects->Release();
 	}
+<<<<<<< .mine
+
+#ifdef WITH_PYTHON
+	if (m_attr_dict) {
+		PyDict_Clear(m_attr_dict); /* in case of circular refs or other weird cases */
+		/* Py_CLEAR: Py_DECREF's and NULL's */
+		Py_CLEAR(m_attr_dict);
+	}
+	// Unregister collision callbacks
+	if (m_collisionCallbacks){
+		UnregisterCollisionCallbacks();
+		Py_CLEAR(m_collisionCallbacks);
+	}
+#endif // WITH_PYTHON
+=======
+>>>>>>> .r60397
 }
 
 KX_GameObject* KX_GameObject::GetClientObject(KX_ClientObjectInfo *info)
@@ -1345,8 +1370,102 @@
 }
 
 
+<<<<<<< .mine
 void KX_GameObject::UnregisterCollisionCallbacks()
 {
+	// Unregister from callbacks
+	KX_Scene* scene = GetScene();
+	PHY_IPhysicsEnvironment* pe = scene->GetPhysicsEnvironment();
+	PHY_IPhysicsController* spc = static_cast<PHY_IPhysicsController*> (GetPhysicsController()->GetUserData());
+	
+	if (!spc){
+		return;
+	}
+	// If we are the last to unregister on this physics controller 
+	if (pe->removeCollisionCallback(spc)){
+		// If we are a sensor object
+		KX_ClientObjectInfo *client_info = static_cast<KX_ClientObjectInfo*>(spc->getNewClientInfo());
+		if (client_info->isSensor())
+			// Remove sensor body from physics world
+			pe->removeSensor(spc);
+	}
+}
+
+void KX_GameObject::RegisterCollisionCallbacks()
+{	
+	// Register from callbacks
+	KX_Scene* scene = GetScene();
+	PHY_IPhysicsEnvironment* pe = scene->GetPhysicsEnvironment();
+	PHY_IPhysicsController* spc = static_cast<PHY_IPhysicsController*> (GetPhysicsController()->GetUserData());
+	if (!spc){
+		return;
+	}
+	// If we are the first to register on this physics controller 
+	if (pe->requestCollisionCallback(spc)){
+		// If we are a sensor object
+		KX_ClientObjectInfo *client_info = static_cast<KX_ClientObjectInfo*>(spc->getNewClientInfo());
+		if (client_info->isSensor())
+			// Add sensor body to physics world
+			pe->addSensor(spc);
+	}
+}
+void KX_GameObject::RunCollisionCallbacks(KX_GameObject *collider, PHY_ContactData *coll_data)
+{	
+	#ifdef WITH_PYTHON
+	Py_ssize_t len;
+	PyObject* collision_callbacks = m_collisionCallbacks;
+
+	if (collision_callbacks && (len=PyList_GET_SIZE(collision_callbacks)))
+	{
+		Py_ssize_t contact_num = (coll_data->data).size();
+		PyObject *contacts = PyList_New(contact_num);
+
+		PHY_VectCollData data = coll_data->data;
+		PHY_VectCollData::iterator beginning = data.begin();
+
+		for (PHY_VectCollData::iterator vit = data.begin(); vit != data.end(); ++vit)
+		{
+			PHY_CollData *dat = (*vit);
+			Py_ssize_t index = vit - beginning;
+
+			// Add the three points
+			PyObject *value = PyList_New((Py_ssize_t)0);
+			PyList_Append(value, PyObjectFrom(dat->m_point1));
+			PyList_Append(value, PyObjectFrom(dat->m_point2));
+			PyList_Append(value, PyObjectFrom(dat->m_normal));
+			PyList_Append(value, PyFloat_FromDouble(dat->m_distance));
+
+			// Add to output
+			PyList_SetItem(contacts, index, value);
+		}
+
+		PyObject* args = Py_BuildValue("(OO)", collider->GetProxy(), contacts); // save python creating each call
+		PyObject *func;
+		PyObject *ret;
+
+		// Iterate the list and run the callbacks
+		for (Py_ssize_t pos=0; pos < len; pos++)
+		{
+			func = PyList_GET_ITEM(collision_callbacks, pos);
+			ret = PyObject_Call(func, args, NULL);
+
+			if (ret == NULL) {
+				PyErr_Print();
+				PyErr_Clear();
+			}
+			else {
+				Py_DECREF(ret);
+			}
+		}
+
+		Py_DECREF(args);
+	}
+	#endif
+}
+
+=======
+void KX_GameObject::UnregisterCollisionCallbacks()
+{
 	if (!GetPhysicsController()) {
 		printf("Warning, trying to unregister collision callbacks for object without collisions: %s!\n", GetName().ReadPtr());
 		return;
@@ -1416,6 +1535,7 @@
 	#endif
 }
 
+>>>>>>> .r60397
 /* Suspend/ resume: for the dynamic behavior, there is a simple
  * method. For the residual motion, there is not. I wonder what the
  * correct solution is for Sumo. Remove from the motion-update tree?
@@ -1782,6 +1902,8 @@
 PyAttributeDef KX_GameObject::Attributes[] = {
 	KX_PYATTRIBUTE_RO_FUNCTION("name",		KX_GameObject, pyattr_get_name),
 	KX_PYATTRIBUTE_RO_FUNCTION("parent",	KX_GameObject, pyattr_get_parent),
+	KX_PYATTRIBUTE_RO_FUNCTION("physicsType",	KX_GameObject, pyattr_get_physics),
+	KX_PYATTRIBUTE_RO_FUNCTION("isActor",	KX_GameObject, pyattr_get_physics_actor),
 	KX_PYATTRIBUTE_RO_FUNCTION("groupMembers",	KX_GameObject, pyattr_get_group_members),
 	KX_PYATTRIBUTE_RO_FUNCTION("groupObject",	KX_GameObject, pyattr_get_group_object),
 	KX_PYATTRIBUTE_RO_FUNCTION("scene",		KX_GameObject, pyattr_get_scene),
@@ -2079,6 +2201,18 @@
 	Py_RETURN_NONE;
 }
 
+PyObject *KX_GameObject::pyattr_get_physics(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef)
+{
+	KX_GameObject* self = static_cast<KX_GameObject*>(self_v);
+	return PyLong_FromLong((long)self->m_physicsType);
+}
+
+PyObject *KX_GameObject::pyattr_get_physics_actor(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef)
+{
+	KX_GameObject* self = static_cast<KX_GameObject*>(self_v);
+	return PyBool_FromLong((long)self->m_physicsActor);
+}
+
 PyObject *KX_GameObject::pyattr_get_group_members(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef)
 {
 	KX_GameObject* self = static_cast<KX_GameObject*>(self_v);
@@ -2089,10 +2223,44 @@
 	Py_RETURN_NONE;
 }
 
+<<<<<<< .mine
 PyObject* KX_GameObject::pyattr_get_collisionCallbacks(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef)
 {
 	KX_GameObject* self = static_cast<KX_GameObject*>(self_v);
+	// Return the existing callbacks
+	if (self->m_collisionCallbacks == NULL)
+	{
+		self->m_collisionCallbacks = PyList_New(0);
+		// Subscribe to collision update from KX_TouchManager
+		self->RegisterCollisionCallbacks();
+	}
+	Py_INCREF(self->m_collisionCallbacks);
+	return self->m_collisionCallbacks;
+}
 
+int KX_GameObject::pyattr_set_collisionCallbacks(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef, PyObject *value)
+{
+	KX_GameObject* self = static_cast<KX_GameObject*>(self_v);
+	
+	if (!PyList_CheckExact(value))
+	{
+		PyErr_SetString(PyExc_ValueError, "Expected a list");
+		return PY_SET_ATTR_FAIL;
+	}
+
+	Py_XDECREF(self->m_collisionCallbacks);
+	Py_INCREF(value);
+
+	self->m_collisionCallbacks = value;
+	
+	return PY_SET_ATTR_SUCCESS;
+}
+
+=======
+PyObject* KX_GameObject::pyattr_get_collisionCallbacks(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef)
+{
+	KX_GameObject* self = static_cast<KX_GameObject*>(self_v);
+
 	// Only objects with a physics controller should have collision callbacks
 	if (!self->GetPhysicsController()) {
 		PyErr_SetString(PyExc_AttributeError, "KX_GameObject.collisionCallbacks: attribute only available for objects with collisions enabled");
@@ -2134,6 +2302,7 @@
 	return PY_SET_ATTR_SUCCESS;
 }
 
+>>>>>>> .r60397
 PyObject* KX_GameObject::pyattr_get_scene(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef)
 {
 	KX_GameObject *self = static_cast<KX_GameObject*>(self_v);
@@ -3588,7 +3757,9 @@
 	}
 	
 	if (PyUnicode_Check(value)) {
-		*object = (KX_GameObject*)SCA_ILogicBrick::m_sCurrentLogicManager->GetGameObjectByName(STR_String( _PyUnicode_AsString(value) ));
+		STR_String obj_name = STR_String(_PyUnicode_AsString(value));
+		SCA_LogicManager* logicmgr = SCA_ILogicBrick::m_sCurrentLogicManager;
+		*object = (KX_GameObject*)logicmgr->GetGameObjectByName(obj_name);
 		
 		if (*object) {
 			return true;
Index: source/gameengine/Ketsji/KX_GameObject.h
===================================================================
--- source/gameengine/Ketsji/KX_GameObject.h	(revision 60397)
+++ source/gameengine/Ketsji/KX_GameObject.h	(working copy)
@@ -39,7 +39,6 @@
 #endif 
 
 #include <stddef.h>
-
 #include "ListValue.h"
 #include "SCA_IObject.h"
 #include "SG_Node.h"
@@ -53,8 +52,10 @@
 #include "DNA_object_types.h"
 #include "SCA_LogicManager.h" /* for ConvertPythonToGameObject to search object names */
 
+
 //Forward declarations.
 struct KX_ClientObjectInfo;
+struct PHY_ContactData;
 class KX_RayCast;
 class RAS_MeshObject;
 class KX_IPhysicsController;
@@ -129,6 +130,8 @@
 	
 public:
 	bool								m_isDeformable;
+	bool								m_physicsActor;
+	enum                                GamePhysicsType {STATIC, DYNAMIC, RIGID_BODY, SOFT_BODY, OCCLUDER, SENSOR, NAVIGATION_MESH, CHARACTER, NO_COLLISION} m_physicsType;
 
 	/**
 	 * Helper function for modules that can't include KX_ClientObjectInfo.h
@@ -153,6 +156,7 @@
 	//
 	PyObject*							m_attr_dict;
 	PyObject*							m_collisionCallbacks;
+	PyObject*							m_collisionCallbacks; 
 #endif
 
 	virtual void	/* This function should be virtual - derived classed override it */
@@ -869,10 +873,12 @@
 		void
 	) { return m_bIsNegativeScaling; }
 
+	void RegisterCollisionCallbacks();
+	void UnregisterCollisionCallbacks();
+	void RunCollisionCallbacks(KX_GameObject *collider, PHY_ContactData *coll_data);
 	/**
 	 * \section Logic bubbling methods.
 	 */
-
 	void RegisterCollisionCallbacks();
 	void UnregisterCollisionCallbacks();
 	void RunCollisionCallbacks(KX_GameObject *collider);
@@ -994,6 +1000,8 @@
 	/* attributes */
 	static PyObject*	pyattr_get_name(void* self_v, const KX_PYATTRIBUTE_DEF *attrdef);
 	static PyObject*	pyattr_get_parent(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef);
+	static PyObject*	pyattr_get_physics(void* self_v, const KX_PYATTRIBUTE_DEF *attrdef);
+	static PyObject*	pyattr_get_physics_actor(void* self_v, const KX_PYATTRIBUTE_DEF *attrdef);
 
 	static PyObject*	pyattr_get_group_object(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef);
 	static PyObject*	pyattr_get_group_members(void *self_v, const KX_PYATTRIBUTE_DEF *attrdef);
Index: source/gameengine/Ketsji/KX_KetsjiEngine.cpp
===================================================================
--- source/gameengine/Ketsji/KX_KetsjiEngine.cpp	(revision 60397)
+++ source/gameengine/Ketsji/KX_KetsjiEngine.cpp	(working copy)
@@ -59,6 +59,7 @@
 #include "KX_PythonInit.h"
 #include "KX_PyConstraintBinding.h"
 #include "PHY_IPhysicsEnvironment.h"
+#include "KX_KetsjiLogicBrickLoop.h"
 
 #ifdef WITH_AUDASPACE
 #  include "AUD_C-API.h"
@@ -111,6 +112,7 @@
 double KX_KetsjiEngine::m_suspendeddelta = 0.0;
 double KX_KetsjiEngine::m_average_framerate = 0.0;
 bool   KX_KetsjiEngine::m_restrict_anim_fps = false;
+bool   KX_KetsjiEngine::m_bFixedTime = false;
 short  KX_KetsjiEngine::m_exitkey = 130; //ESC Key
 
 
@@ -132,7 +134,6 @@
 
 	m_bInitialized(false),
 	m_activecam(0),
-	m_bFixedTime(false),
 	
 	m_firstframe(true),
 	
@@ -141,7 +142,6 @@
 	m_previousClockTime(0.f),
 	m_previousAnimTime(0.f),
 
-
 	m_exitcode(KX_EXIT_REQUEST_NO_REQUEST),
 	m_exitstring(""),
 	
@@ -157,6 +157,8 @@
 	m_curreye(0),
 
 	m_logger(NULL),
+	m_logicloop(NULL),
+	m_logiccallbacks(NULL),
 	
 	// Set up timing info display variables
 	m_show_framerate(false),
@@ -179,6 +181,7 @@
 {
 	// Initialize the time logger
 	m_logger = new KX_TimeCategoryLogger (25);
+	m_logicloop = new KX_KetsjiLogicBrickLoop (this);
 
 	for (int i = tc_first; i < tc_numCategories; i++)
 		m_logger->AddCategory((KX_TimeCategory)i);
@@ -196,6 +199,14 @@
 KX_KetsjiEngine::~KX_KetsjiEngine()
 {
 	delete m_logger;
+	delete m_logicloop;
+	delete m_keyboarddevice;
+	delete m_mousedevice;
+	delete m_rendertools;
+	delete m_rasterizer;
+	delete m_networkdevice;
+	delete m_kxsystem;
+
 	if (m_usedome)
 		delete m_dome;
 
@@ -204,16 +215,24 @@
 #endif
 }
 
+void KX_KetsjiEngine::SetEngineCallbacks(KX_EngineCallbackData *callbacks)
+{
+	m_logiccallbacks = callbacks;
+}
 
 
+void KX_KetsjiEngine::SetLogger(KX_TimeCategoryLogger* logger)
+{
+	MT_assert(logger);
+	m_logger = logger;
+}
+
 void KX_KetsjiEngine::SetKeyboardDevice(SCA_IInputDevice* keyboarddevice)
 {
 	MT_assert(keyboarddevice);
 	m_keyboarddevice = keyboarddevice;
 }
 
-
-
 void KX_KetsjiEngine::SetMouseDevice(SCA_IInputDevice* mousedevice)
 {
 	MT_assert(mousedevice);
@@ -221,7 +240,6 @@
 }
 
 
-
 void KX_KetsjiEngine::SetNetworkDevice(NG_NetworkDeviceInterface* networkdevice)
 {
 	MT_assert(networkdevice);
@@ -269,7 +287,21 @@
 }
 #endif
 
+void KX_KetsjiEngine::SetLogicLoop(KX_KetsjiLogicLoop* logicloop)
+{
+	// Get existing loop and delete it
+	KX_KetsjiLogicLoop *old_loop = m_logicloop;
 
+	if (old_loop)
+	{
+		delete old_loop;
+		old_loop = NULL;
+	}
+
+	MT_assert(logicloop);
+	m_logicloop = logicloop;
+}
+
 void KX_KetsjiEngine::SetSceneConverter(KX_ISceneConverter* sceneconverter)
 {
 	MT_assert(sceneconverter);
@@ -556,292 +588,22 @@
 //#include "PIL_time.h"
 //#include "LinearMath/btQuickprof.h"
 
-
-bool KX_KetsjiEngine::NextFrame()
+void KX_KetsjiEngine::UpdateEvents()
 {
-	double timestep = 1.0/m_ticrate;
-	double framestep = timestep;
-	//	static hidden::Clock sClock;
-
-	m_logger->StartLog(tc_services, m_kxsystem->GetTimeInSeconds(),true);
-
-	//float dt = sClock.getTimeMicroseconds() * 0.000001f;
-	//sClock.reset();
-
-	if (m_bFixedTime) {
-		m_clockTime += timestep;
-	}
-	else {
-		// m_clockTime += dt;
-		m_clockTime = m_kxsystem->GetTimeInSeconds();
-	}
-	
-	double deltatime = m_clockTime - m_frameTime;
-	if (deltatime<0.f)
-	{
-		// We got here too quickly, which means there is nothing todo, just return and don't render.
-		// Not sure if this is the best fix, but it seems to stop the jumping framerate issue (#33088)
-		return false;
-	}
-
-
-	// Compute the number of logic frames to do each update (fixed tic bricks)
-	int frames =int(deltatime*m_ticrate+1e-6);
-//	if (frames>1)
-//		printf("****************************************");
-//	printf("dt = %f, deltatime = %f, frames = %d\n",dt, deltatime,frames);
-	
-//	if (!frames)
-//		PIL_sleep_ms(1);
-	
-	KX_SceneList::iterator sceneit;
-	
-	if (frames>m_maxPhysicsFrame)
-	{
-	
-	//	printf("framedOut: %d\n",frames);
-		m_frameTime+=(frames-m_maxPhysicsFrame)*timestep;
-		frames = m_maxPhysicsFrame;
-	}
-	
-
-	bool doRender = frames>0;
-
-	if (frames > m_maxLogicFrame)
-	{
-		framestep = (frames*timestep)/m_maxLogicFrame;
-		frames = m_maxLogicFrame;
-	}
-
-	while (frames)
-	{
-	
-
-		m_frameTime += framestep;
-		
-		m_sceneconverter->MergeAsyncLoads();
-
-		for (sceneit = m_scenes.begin();sceneit != m_scenes.end(); ++sceneit)
-		// for each scene, call the proceed functions
-		{
-			KX_Scene* scene = *sceneit;
-	
-			/* Suspension holds the physics and logic processing for an
-			 * entire scene. Objects can be suspended individually, and
-			 * the settings for that precede the logic and physics
-			 * update. */
-			m_logger->StartLog(tc_logic, m_kxsystem->GetTimeInSeconds(), true);
-
-			m_sceneconverter->resetNoneDynamicObjectToIpo();//this is for none dynamic objects with ipo
-
-			scene->UpdateObjectActivity();
-	
-			if (!scene->IsSuspended())
-			{
-				// if the scene was suspended recalcutlate the delta tu "curtime"
-				m_suspendedtime = scene->getSuspendedTime();
-				if (scene->getSuspendedTime()!=0.0)
-					scene->setSuspendedDelta(scene->getSuspendedDelta()+m_clockTime-scene->getSuspendedTime());
-				m_suspendeddelta = scene->getSuspendedDelta();
-
-				
-				m_logger->StartLog(tc_network, m_kxsystem->GetTimeInSeconds(), true);
-				SG_SetActiveStage(SG_STAGE_NETWORK);
-				scene->GetNetworkScene()->proceed(m_frameTime);
-	
-				//m_logger->StartLog(tc_scenegraph, m_kxsystem->GetTimeInSeconds(), true);
-				//SG_SetActiveStage(SG_STAGE_NETWORK_UPDATE);
-				//scene->UpdateParents(m_frameTime);
-				
-				m_logger->StartLog(tc_physics, m_kxsystem->GetTimeInSeconds(), true);
-				SG_SetActiveStage(SG_STAGE_PHYSICS1);
-				// set Python hooks for each scene
-#ifdef WITH_PYTHON
-				PHY_SetActiveEnvironment(scene->GetPhysicsEnvironment());
-#endif
-				KX_SetActiveScene(scene);
-	
-				scene->GetPhysicsEnvironment()->endFrame();
-				
-				// Update scenegraph after physics step. This maps physics calculations
-				// into node positions.
-				//m_logger->StartLog(tc_scenegraph, m_kxsystem->GetTimeInSeconds(), true);
-				//SG_SetActiveStage(SG_STAGE_PHYSICS1_UPDATE);
-				//scene->UpdateParents(m_frameTime);
-				
-				// Process sensors, and controllers
-				m_logger->StartLog(tc_logic, m_kxsystem->GetTimeInSeconds(), true);
-				SG_SetActiveStage(SG_STAGE_CONTROLLER);
-				scene->LogicBeginFrame(m_frameTime);
-	
-				// Scenegraph needs to be updated again, because Logic Controllers 
-				// can affect the local matrices.
-				m_logger->StartLog(tc_scenegraph, m_kxsystem->GetTimeInSeconds(), true);
-				SG_SetActiveStage(SG_STAGE_CONTROLLER_UPDATE);
-				scene->UpdateParents(m_frameTime);
-	
-				// Process actuators
-	
-				// Do some cleanup work for this logic frame
-				m_logger->StartLog(tc_logic, m_kxsystem->GetTimeInSeconds(), true);
-				SG_SetActiveStage(SG_STAGE_ACTUATOR);
-				scene->LogicUpdateFrame(m_frameTime, true);
-				
-				scene->LogicEndFrame();
-	
-				// Actuators can affect the scenegraph
-				m_logger->StartLog(tc_scenegraph, m_kxsystem->GetTimeInSeconds(), true);
-				SG_SetActiveStage(SG_STAGE_ACTUATOR_UPDATE);
-				scene->UpdateParents(m_frameTime);
-
-				if (!GetRestrictAnimationFPS())
-				{
-					m_logger->StartLog(tc_animations, m_kxsystem->GetTimeInSeconds(), true);
-					SG_SetActiveStage(SG_STAGE_ANIMATION_UPDATE);
-					scene->UpdateAnimations(m_frameTime);
-				}
-
-				m_logger->StartLog(tc_physics, m_kxsystem->GetTimeInSeconds(), true);
-				SG_SetActiveStage(SG_STAGE_PHYSICS2);
-				scene->GetPhysicsEnvironment()->beginFrame();
-		
-				// Perform physics calculations on the scene. This can involve 
-				// many iterations of the physics solver.
-				scene->GetPhysicsEnvironment()->proceedDeltaTime(m_frameTime,timestep,framestep);//m_deltatimerealDeltaTime);
-
-				m_logger->StartLog(tc_scenegraph, m_kxsystem->GetTimeInSeconds(), true);
-				SG_SetActiveStage(SG_STAGE_PHYSICS2_UPDATE);
-				scene->UpdateParents(m_frameTime);
-			
-			
-				if (m_animation_record)
-				{
-					m_sceneconverter->WritePhysicsObjectToAnimationIpo(++m_currentFrame);
-				}
-
-				scene->setSuspendedTime(0.0);
-			} // suspended
-			else
-				if (scene->getSuspendedTime()==0.0)
-					scene->setSuspendedTime(m_clockTime);
-			
-			m_logger->StartLog(tc_services, m_kxsystem->GetTimeInSeconds(), true);
-		}
-
-		// update system devices
-		m_logger->StartLog(tc_logic, m_kxsystem->GetTimeInSeconds(), true);
-		if (m_keyboarddevice)
-			m_keyboarddevice->NextFrame();
-	
-		if (m_mousedevice)
-			m_mousedevice->NextFrame();
-		
-		if (m_networkdevice)
-			m_networkdevice->NextFrame();
-
-		// scene management
-		ProcessScheduledScenes();
-		
-		frames--;
-	}
-
-	bool bUseAsyncLogicBricks= false;//true;
-
-	if (bUseAsyncLogicBricks)
-	{
-		// Logic update sub frame: this will let some logic bricks run at the
-		// full frame rate.
-		for (sceneit = m_scenes.begin();sceneit != m_scenes.end(); ++sceneit)
-		// for each scene, call the proceed functions
-		{
-			KX_Scene* scene = *sceneit;
-
-			if (!scene->IsSuspended())
-			{
-				// if the scene was suspended recalcutlate the delta tu "curtime"
-				m_suspendedtime = scene->getSuspendedTime();
-				if (scene->getSuspendedTime()!=0.0)
-					scene->setSuspendedDelta(scene->getSuspendedDelta()+m_clockTime-scene->getSuspendedTime());
-				m_suspendeddelta = scene->getSuspendedDelta();
-				
-				// set Python hooks for each scene
-#ifdef WITH_PYTHON
-				PHY_SetActiveEnvironment(scene->GetPhysicsEnvironment());
-#endif
-				KX_SetActiveScene(scene);
-				
-				m_logger->StartLog(tc_scenegraph, m_kxsystem->GetTimeInSeconds(), true);
-				SG_SetActiveStage(SG_STAGE_PHYSICS1);
-				scene->UpdateParents(m_clockTime);
-
-				// Perform physics calculations on the scene. This can involve 
-				// many iterations of the physics solver.
-				m_logger->StartLog(tc_physics, m_kxsystem->GetTimeInSeconds(), true);
-				scene->GetPhysicsEnvironment()->proceedDeltaTime(m_clockTime,timestep,timestep);
-				// Update scenegraph after physics step. This maps physics calculations
-				// into node positions.
-				m_logger->StartLog(tc_scenegraph, m_kxsystem->GetTimeInSeconds(), true);
-				SG_SetActiveStage(SG_STAGE_PHYSICS2);
-				scene->UpdateParents(m_clockTime);
-				
-				// Do some cleanup work for this logic frame
-				m_logger->StartLog(tc_logic, m_kxsystem->GetTimeInSeconds(), true);
-				scene->LogicUpdateFrame(m_clockTime, false);
-
-				// Actuators can affect the scenegraph
-				m_logger->StartLog(tc_scenegraph, m_kxsystem->GetTimeInSeconds(), true);
-				SG_SetActiveStage(SG_STAGE_ACTUATOR);
-				scene->UpdateParents(m_clockTime);
-
-				scene->setSuspendedTime(0.0);
-			} // suspended
-			else
-				if (scene->getSuspendedTime()==0.0)
-					scene->setSuspendedTime(m_clockTime);
-
-			m_logger->StartLog(tc_services, m_kxsystem->GetTimeInSeconds(), true);
-		}
-	}
-
-		
-	// Handle the animations independently of the logic time step
-	if (GetRestrictAnimationFPS())
-	{
-		double clocktime = m_kxsystem->GetTimeInSeconds();
-		m_logger->StartLog(tc_animations, clocktime, true);
-		SG_SetActiveStage(SG_STAGE_ANIMATION_UPDATE);
-
-		double anim_timestep = 1.0/KX_GetActiveScene()->GetAnimationFPS();
-		if (clocktime - m_previousAnimTime > anim_timestep)
-		{
-			// Sanity/debug print to make sure we're actually going at the fps we want (should be close to anim_timestep)
-			// printf("Anim fps: %f\n", 1.0/(m_clockTime - m_previousAnimTime));
-			m_previousAnimTime = clocktime;
-			for (sceneit = m_scenes.begin();sceneit != m_scenes.end(); ++sceneit)
-			{
-				(*sceneit)->UpdateAnimations(clocktime);
-			}
-		}
-	}
-	
-	// Start logging time spend outside main loop
-	m_logger->StartLog(tc_outside, m_kxsystem->GetTimeInSeconds(), true);
-	
-	return doRender;
+	m_logiccallbacks->eventcallback(m_logiccallbacks);
 }
 
-
-
 void KX_KetsjiEngine::Render()
 {
+	m_logiccallbacks->rendercallback(m_logiccallbacks);
+
 	if (m_usedome) {
 		RenderDome();
 		return;
 	}
 	KX_Scene* firstscene = *m_scenes.begin();
 	const RAS_FrameSettings &framesettings = firstscene->GetFramingType();
-
-	m_logger->StartLog(tc_rasterizer, m_kxsystem->GetTimeInSeconds(), true);
+	 
 	SG_SetActiveStage(SG_STAGE_RENDER);
 
 	// hiding mouse cursor each frame
@@ -993,14 +755,11 @@
 }
 
 
-
 void KX_KetsjiEngine::SetNameNextGame(const STR_String& nextgame)
 {
 	m_exitstring = nextgame;
 }
 
-
-
 int KX_KetsjiEngine::GetExitCode()
 {
 	// if a gameactuator has set an exitcode or if there are no scenes left
@@ -1383,6 +1142,10 @@
 
 		// cleanup all the stuff
 		m_rasterizer->Exit();
+
+		// Disconnect network device
+		if (m_networkdevice)
+			m_networkdevice->Disconnect();
 	}
 }
 
@@ -1817,28 +1580,57 @@
 	m_bFixedTime = bUseFixedTime;
 }
 
+bool KX_KetsjiEngine::GetAnimationRecord()
+{
+	return m_animation_record;
+}
 
-void	KX_KetsjiEngine::SetAnimRecordMode(bool animation_record, int startFrame)
+int KX_KetsjiEngine::GetAnimationFrame()
 {
+	return m_currentFrame;
+}
+
+void KX_KetsjiEngine::SetAnimationFrame(int frame)
+{
+	m_currentFrame = frame;
+}
+
+void KX_KetsjiEngine::SetAnimRecordMode(bool animation_record)
+{
 	m_animation_record = animation_record;
+
 	if (animation_record)
 	{
 		//when recording physics keyframes, run at a variable (capped) frame rate (fixed time == full speed)
 		m_bFixedTime = false;
 	}
-	m_currentFrame = startFrame;
 }
 
-bool KX_KetsjiEngine::GetUseFixedTime(void) const
+bool KX_KetsjiEngine::GetUseFixedTime() 
 {
 	return m_bFixedTime;
 }
 
+void KX_KetsjiEngine::SetSuspendedTime(double time)
+{
+	m_suspendedtime = time;
+}
+
+void KX_KetsjiEngine::SetSuspendedDelta(double time)
+{
+	m_suspendeddelta = time;
+}
+
 double KX_KetsjiEngine::GetSuspendedDelta()
 {
 	return m_suspendeddelta;
 }
 
+double KX_KetsjiEngine::GetSuspendedTime()
+{
+	return m_suspendedtime;
+}
+
 double KX_KetsjiEngine::GetTicRate()
 {
 	return m_ticrate;
@@ -1889,6 +1681,16 @@
 	return m_clockTime;
 }
 
+void KX_KetsjiEngine::SetClockTime(double time)
+{
+	m_clockTime = time;
+}
+
+void KX_KetsjiEngine::SetFrameTime(double time)
+{
+	m_frameTime = time;
+}
+
 double KX_KetsjiEngine::GetFrameTime(void) const
 {
 	return m_frameTime;
Index: source/gameengine/Ketsji/KX_KetsjiEngine.h
===================================================================
--- source/gameengine/Ketsji/KX_KetsjiEngine.h	(revision 60397)
+++ source/gameengine/Ketsji/KX_KetsjiEngine.h	(working copy)
@@ -40,6 +40,8 @@
 #include "KX_Scene.h"
 #include "KX_Python.h"
 #include "KX_WorldInfo.h"
+#include "KX_EngineCallbackData.h"
+#include "KX_KetsjiLogicLoop.h"
 #include <vector>
 
 class KX_TimeCategoryLogger;
@@ -59,6 +61,25 @@
 	KX_EXIT_REQUEST_MAX
 };
 
+
+
+
+/** Categories for profiling display. */
+typedef enum {
+		tc_first = 0,
+		tc_physics = 0,
+		tc_logic,
+		tc_animations,
+		tc_network,
+		tc_scenegraph,
+		tc_rasterizer,
+		tc_services,	// time spent in miscelaneous activities
+		tc_overhead,	// profile info drawing overhead
+		tc_outside,		// time spent outside main loop
+		tc_latency,		// time spent waiting on the gpu
+		tc_numCategories
+	} KX_TimeCategory;
+
 typedef struct {
 	short matmode;
 	short glslflag;
@@ -77,6 +98,7 @@
 	class RAS_IRenderTools*				m_rendertools;
 	class KX_ISceneConverter*			m_sceneconverter;
 	class NG_NetworkDeviceInterface*	m_networkdevice;
+	class KX_KetsjiLogicLoop*			m_logicloop;
 #ifdef WITH_PYTHON
 	/* borrowed from sys.modules["__main__"], don't manage ref's */
 	PyObject*					m_pythondictionary;
@@ -102,7 +124,6 @@
 
 	bool				m_bInitialized;
 	int					m_activecam;
-	bool				m_bFixedTime;
 	
 	
 	bool				m_firstframe;
@@ -120,6 +141,7 @@
 	static double			m_anim_framerate; /* for animation playback only - ipo and action */
 
 	static bool				m_restrict_anim_fps;
+	static bool				m_bFixedTime;
 
 	static double			m_suspendedtime;
 	static double			m_suspendeddelta;
@@ -148,25 +170,10 @@
 
 	bool m_stereo;
 	int m_curreye;
-
-	/** Categories for profiling display. */
-	typedef enum {
-		tc_first = 0,
-		tc_physics = 0,
-		tc_logic,
-		tc_animations,
-		tc_network,
-		tc_scenegraph,
-		tc_rasterizer,
-		tc_services,	// time spent in miscelaneous activities
-		tc_overhead,	// profile info drawing overhead
-		tc_outside,		// time spent outside main loop
-		tc_latency,		// time spent waiting on the gpu
-		tc_numCategories
-	} KX_TimeCategory;
-
+	
 	/** Time logger. */
 	KX_TimeCategoryLogger*	m_logger;
+	KX_EngineCallbackData* m_logiccallbacks;
 	
 	/** Labels for profiling display. */
 	static const char		m_profileLabels[tc_numCategories][15];
@@ -208,6 +215,7 @@
 	void					SetBackGround(KX_WorldInfo* worldinfo);
 
 public:
+
 	KX_KetsjiEngine(class KX_ISystem* system);
 	virtual ~KX_KetsjiEngine();
 
@@ -219,28 +227,36 @@
 	void			SetCanvas(RAS_ICanvas* canvas);
 	void			SetRenderTools(RAS_IRenderTools* rendertools);
 	void			SetRasterizer(RAS_IRasterizer* rasterizer);
+	void			SetLogicLoop(KX_KetsjiLogicLoop* logicloop);
+	void			SetLogger(KX_TimeCategoryLogger* logger);
+	void			SetEngineCallbacks(KX_EngineCallbackData* callbacks);
+
 #ifdef WITH_PYTHON
 	void			SetPyNamespace(PyObject *pythondictionary);
 	PyObject*		GetPyNamespace() { return m_pythondictionary; }
 	PyObject*		GetPyProfileDict();
 #endif
 	void			SetSceneConverter(KX_ISceneConverter* sceneconverter);
-	void			SetAnimRecordMode(bool animation_record, int startFrame);
+	void			SetAnimRecordMode(bool animation_record);
 
+	KX_EngineCallbackData*		GetEngineCallbacks() {return m_logiccallbacks;}
 	RAS_IRasterizer*		GetRasterizer() { return m_rasterizer; }
 	RAS_ICanvas*		    GetCanvas() { return m_canvas; }
 	RAS_IRenderTools*	    GetRenderTools() { return m_rendertools; }
 	SCA_IInputDevice*		GetKeyboardDevice() { return m_keyboarddevice; }
 	SCA_IInputDevice*		GetMouseDevice() { return m_mousedevice; }
-
+	KX_TimeCategoryLogger*		GetLogger() { return m_logger; }
+	NG_NetworkDeviceInterface*	GetNetworkDevice() { return m_networkdevice; }
+	KX_ISceneConverter*			GetSceneConverter() { return m_sceneconverter; }
+	KX_KetsjiLogicLoop*		GetLogicLoop() { return m_logicloop; }
+	
 	/// Dome functions
 	void			InitDome(short res, short mode, short angle, float resbuf, short tilt, struct Text* text); 
 	void			EndDome();
 	void			RenderDome();
 	bool			m_usedome;
 
-	///returns true if an update happened to indicate -> Render
-	bool			NextFrame();
+	void			UpdateEvents();
 	void			Render();
 	
 	void			StartEngine(bool clearIpo);
@@ -250,6 +266,7 @@
 	void			RequestExit(int exitrequestmode);
 	void			SetNameNextGame(const STR_String& nextgame);
 	int				GetExitCode();
+
 	const STR_String&	GetExitString();
 
 	KX_SceneList*	CurrentScenes();
@@ -265,8 +282,10 @@
 	void			GetSceneViewport(KX_Scene* scene, KX_Camera* cam, RAS_Rect& area, RAS_Rect& viewport);
 
 	void SetDrawType(int drawingtype);
+
 	int  GetDrawType() { return m_drawingmode; }
 
+public:
 	void SetCameraZoom(float camzoom);
 	
 	void EnableCameraOverride(const STR_String& forscene);
@@ -276,35 +295,44 @@
 	void SetCameraOverrideViewMatrix(const MT_CmMatrix4x4& mat);
 	void SetCameraOverrideClipping(float near, float far);
 	void SetCameraOverrideLens(float lens);
-	
-	/**
-	 * Sets display of all frames.
-	 * \param bUseFixedTime	New setting for display all frames.
-	 */ 
-	void SetUseFixedTime(bool bUseFixedTime);
 
 	/**
 	 * Returns display of all frames.
 	 * \return Current setting for display all frames.
 	 */ 
-	bool GetUseFixedTime(void) const;
-
+	double GetPreviousAnimTime(){return m_previousAnimTime;};
+	void SetPreviousAnimTime(double time){m_previousAnimTime = time;};
 	/**
 	 * Returns current render frame clock time
 	 */
+	void SetClockTime(double time);
 	double GetClockTime(void) const;
 	/**
 	 * Returns current logic frame clock time
 	 */
+	void SetFrameTime(double time);
 	double GetFrameTime(void) const;
 
 	double GetRealTime(void) const;
+	
 	/**
+	 * Sets display of all frames.
+	 * \param bUseFixedTime	New setting for display all frames.
+	 */ 
+	static void SetUseFixedTime(bool bUseFixedTime);
+
+	static bool GetUseFixedTime();
+
+	/**
 	 * Returns the difference between the local time of the scene (when it
 	 * was running and not suspended) and the "curtime"
 	 */
 	static double GetSuspendedDelta();
+	static double GetSuspendedTime();
 
+	static void SetSuspendedTime(double time);
+	static void SetSuspendedDelta(double time);
+
 	/**
 	 * Gets the number of logic updates per second.
 	 */
@@ -334,7 +362,12 @@
 	 * Gets whether or not to lock animation updates to the animframerate
 	 */
 	static bool GetRestrictAnimationFPS();
+	
+	bool GetAnimationRecord();
 
+	int GetAnimationFrame();
+	void SetAnimationFrame(int frame);
+
 	/**
 	 * Sets whether or not to lock animation updates to the animframerate
 	 */
@@ -425,6 +458,7 @@
 	 * It's only called from Blenderplayer.
 	 */
 	void			Resize();
+	void			ProcessScheduledScenes(void);
 
 protected:
 	/**
@@ -433,7 +467,6 @@
 	 * SceneListsChanged(void) is called.
 	 * \see SceneListsChanged(void).
 	 */
-	void			ProcessScheduledScenes(void);
 
 	/**
 	 * This method is invoked when the scene lists have changed.
Index: source/gameengine/Ketsji/KX_KetsjiLogicBrickLoop.cpp
===================================================================
--- source/gameengine/Ketsji/KX_KetsjiLogicBrickLoop.cpp	(revision 0)
+++ source/gameengine/Ketsji/KX_KetsjiLogicBrickLoop.cpp	(working copy)
@@ -0,0 +1,216 @@
+#include "KX_KetsjiLogicBrickLoop.h"
+#include "KX_KetsjiEngine.h"
+#include "KX_KetsjiLogicLoop.h"
+#include "PHY_IPhysicsEnvironment.h"
+#include "KX_PyConstraintBinding.h"
+#include "KX_TimeCategoryLogger.h"
+#include "KX_PythonInit.h"
+#include "NG_NetworkScene.h"
+#include "NG_NetworkDeviceInterface.h"
+#include "KX_ISceneConverter.h"
+#include "SCA_IInputDevice.h"
+
+KX_KetsjiLogicBrickLoop::KX_KetsjiLogicBrickLoop(KX_KetsjiEngine* engine): KX_KetsjiLogicLoop(engine)
+{
+};
+
+
+void KX_KetsjiLogicBrickLoop::GiveHandle()
+{
+	while (!m_engine->GetExitCode())
+	{
+		// Update keyboard and mouse events
+		m_engine->UpdateEvents();
+		NextFrame();
+	}
+};
+
+void KX_KetsjiLogicBrickLoop::NextFrame()
+{
+	KX_TimeCategoryLogger* logger = m_engine->GetLogger();
+
+	double timestep = 1.0 / m_engine->GetTicRate();
+	double framestep = timestep;
+	
+	// Start time logging for "services"
+	StartProfile(tc_services);
+
+	// Increment engine time by fixed timestep
+	if (m_engine->GetUseFixedTime()) {
+		m_engine->SetClockTime(m_engine->GetClockTime() + timestep);
+	}
+	// Or use real deltatime
+	else 
+	{
+		m_engine->SetClockTime(GetTime());
+	}
+
+	// Get deltatime duration
+	double deltatime = m_engine->GetClockTime() - m_engine->GetFrameTime();
+	
+	// We got here too quickly, which means there is nothing todo, just return and don't render.
+	// Not sure if this is the best fix, but it seems to stop the jumping framerate issue (#33088)
+	if (deltatime < 0.f)
+		return;
+
+	// Compute the number of logic frames to do each update (fixed tic bricks)
+	int frames = int(deltatime * m_engine->GetTicRate() + 1e-6);
+	
+	int maxPhysicsFrames = m_engine->GetMaxPhysicsFrame();
+	// First, enforce a limit on the number of frames according to physics
+	if (frames > maxPhysicsFrames)
+	{
+		m_engine->SetFrameTime(m_engine->GetFrameTime() + (frames - maxPhysicsFrames) * timestep);
+		frames = maxPhysicsFrames;
+	}
+
+	// Assert we want to render
+	bool doRender = frames > 0;
+
+	int maxLogicFrames = m_engine->GetMaxLogicFrame();
+
+	// Now enforce limit on frames according to logic maximum
+	if (frames > maxLogicFrames)
+	{
+		framestep = (frames * timestep) / maxLogicFrames;
+		frames = maxLogicFrames;
+	}
+
+	// While we have frames to update with
+	double frametime;
+
+	while (frames)
+	{
+		frametime = m_engine->GetFrameTime() + framestep;
+		m_engine->SetFrameTime(frametime);
+
+		KX_SceneList* scenes = m_engine->CurrentScenes();
+
+		int scene_count = scenes->size();
+
+		for (int i=0; i < scene_count; i++)
+		// for each scene, call the proceed functions
+		{
+			KX_Scene* scene = scenes->at(i);
+	
+			/* Suspension holds the physics and logic processing for an
+			 * entire scene. Objects can be suspended individually, and
+			 * the settings for that precede the logic and physics
+			 * update. */
+			StartProfile(tc_logic);
+
+			m_engine->GetSceneConverter()->resetNoneDynamicObjectToIpo();//this is for none dynamic objects with ipo
+
+			scene->UpdateObjectActivity();
+	
+			if (!scene->IsSuspended())
+			{
+				// if the scene was suspended recalcutlate the delta tu "curtime"
+				m_engine->SetSuspendedTime(scene->getSuspendedTime());
+
+				if (scene->getSuspendedTime()!=0.0)
+					scene->setSuspendedDelta(scene->getSuspendedDelta() + m_engine->GetClockTime()-scene->getSuspendedTime());
+
+				m_engine->SetSuspendedDelta(scene->getSuspendedDelta());
+
+				StartProfile(tc_network);
+				SG_SetActiveStage(SG_STAGE_NETWORK);
+				ReceiveMessages(frametime);
+				
+				StartProfile(tc_physics);
+				SG_SetActiveStage(SG_STAGE_PHYSICS1);
+
+				// set Python hooks for each scene
+				SetCurrentScene(scene);
+	
+				// Update scenegraph after physics step. This maps physics calculations
+				// into node positions.
+				scene->GetPhysicsEnvironment()->endFrame();
+				
+				UpdateLogicBricks(frametime);
+
+				if (!m_engine->GetRestrictAnimationFPS())
+				{
+					StartProfile(tc_animations);
+					SG_SetActiveStage(SG_STAGE_ANIMATION_UPDATE);
+					UpdateAnimations(frametime);
+				}
+
+				StartProfile(tc_physics);
+				SG_SetActiveStage(SG_STAGE_PHYSICS2);
+				scene->GetPhysicsEnvironment()->beginFrame();
+		
+				// Perform physics calculations on the scene. This can involve 
+				// many iterations of the physics solver.
+				scene->GetPhysicsEnvironment()->proceedDeltaTime(frametime, timestep, framestep);//m_deltatime realDeltaTime);
+
+				StartProfile(tc_scenegraph);
+				SG_SetActiveStage(SG_STAGE_PHYSICS2_UPDATE);
+				scene->UpdateParents(frametime);
+			
+				if (m_engine->GetAnimationRecord())
+				{
+					int next_frame = m_engine->GetAnimationFrame() + 1;
+					// Set as next frame
+					m_engine->SetAnimationFrame(next_frame);
+					// Record this frame
+					m_engine->GetSceneConverter()->WritePhysicsObjectToAnimationIpo(next_frame);
+				}
+
+				scene->setSuspendedTime(0.0);
+			} // suspended
+			else
+				if (scene->getSuspendedTime()==0.0)
+					scene->setSuspendedTime(m_engine->GetClockTime());
+			
+			StartProfile(tc_services);
+		}
+
+		StartProfile(tc_outside);
+		
+		// update system devices
+		UpdateKeyboard();
+		UpdateMouse();
+		UpdateMessages();
+
+		// scene management
+		UpdateScenes();
+		
+		frames--;
+	}
+
+	if (m_engine->GetRestrictAnimationFPS())
+	{
+		double clocktime = GetTime();
+
+		StartProfile(tc_animations, clocktime);
+		SG_SetActiveStage(SG_STAGE_ANIMATION_UPDATE);
+
+		double anim_timestep = 1.0 / KX_GetActiveScene()->GetAnimationFPS();
+
+		if (clocktime - m_engine->GetPreviousAnimTime() > anim_timestep)
+		{
+			m_engine->SetPreviousAnimTime(clocktime);
+
+			KX_SceneList* scenes = m_engine->CurrentScenes();
+			int scene_count = scenes->size();
+			for (int i=0; i < scene_count; i++)
+			// for each scene, call the proceed functions
+			{
+				KX_Scene* scene = scenes->at(i);
+				// update the animations for the "current scene"
+				SetCurrentScene(scene);
+				UpdateAnimations(clocktime);
+			}
+		}
+	}
+	
+	StartProfile(tc_outside);
+
+	// If we want to render
+	if (doRender)
+	{
+		StartProfile(tc_rasterizer);
+		UpdateRender();
+	}
+};
\ No newline at end of file
Index: source/gameengine/Ketsji/KX_KetsjiLogicBrickLoop.h
===================================================================
--- source/gameengine/Ketsji/KX_KetsjiLogicBrickLoop.h	(revision 0)
+++ source/gameengine/Ketsji/KX_KetsjiLogicBrickLoop.h	(working copy)
@@ -0,0 +1,15 @@
+#ifndef __KX_KETSJILOGICBRICKLOOP_H__
+#define __KX_KETSJILOGICBRICKLOOP_H__
+
+#include "KX_KetsjiLogicLoop.h"
+#include "KX_KetsjiEngine.h"
+
+class KX_KetsjiLogicBrickLoop : public KX_KetsjiLogicLoop
+{
+public:
+	KX_KetsjiLogicBrickLoop(KX_KetsjiEngine *engine);
+	void GiveHandle();
+	void NextFrame();
+};
+
+#endif
\ No newline at end of file
Index: source/gameengine/Ketsji/KX_KetsjiLogicLoop.cpp
===================================================================
--- source/gameengine/Ketsji/KX_KetsjiLogicLoop.cpp	(revision 0)
+++ source/gameengine/Ketsji/KX_KetsjiLogicLoop.cpp	(working copy)
@@ -0,0 +1,191 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): none yet.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ *
+ */
+
+/** \file gameengine/Ketsji/KX_KetsjiLogicLoop.cpp
+ *  \ingroup ketsji
+ */
+
+#ifdef _MSC_VER
+#  pragma warning (disable:4786)
+#endif
+
+#include <iostream>
+#include <stdio.h>
+
+#include "KX_KetsjiLogicLoop.h"
+#include "PHY_IPhysicsEnvironment.h"
+#include "KX_PyConstraintBinding.h"
+#include "KX_KetsjiEngine.h"
+#include "KX_TimeCategoryLogger.h"
+#include "KX_Scene.h"
+#include "SCA_IInputDevice.h"
+#include "NG_NetworkScene.h"
+#include "KX_ISceneConverter.h"
+#include "KX_PythonInit.h"
+#include "NG_NetworkDeviceInterface.h"
+
+KX_KetsjiLogicLoop::KX_KetsjiLogicLoop(KX_KetsjiEngine* engine):
+m_engine(engine)
+{};
+
+// Start profiling this category
+void KX_KetsjiLogicLoop::StartProfile(int profile_id, double currenttime, bool stop_others)
+{
+	if (currenttime == NULL)
+		currenttime = GetTime();
+
+	m_engine->GetLogger()->StartLog(profile_id, currenttime, stop_others);
+}
+
+// Stop profiling this category
+void KX_KetsjiLogicLoop::StopProfile(int profile_id, double currenttime)
+{
+	if (currenttime == NULL)
+		currenttime = GetTime();
+
+	m_engine->GetLogger()->EndLog(profile_id, currenttime);
+}
+
+// Returns the current engine time
+double KX_KetsjiLogicLoop::GetTime() 
+{
+	return m_engine->GetRealTime(); 
+};
+
+// Asks engine to render screen
+void KX_KetsjiLogicLoop::UpdateRender()
+{
+	m_engine->Render();
+}
+
+// Update the blender events
+void KX_KetsjiLogicLoop::UpdateBlender()
+{
+	m_engine->UpdateEvents();
+}
+
+// Update the logic brick sytems
+void KX_KetsjiLogicLoop::UpdateLogicBricks(double current_time)
+{
+	KX_Scene *scene = KX_GetActiveScene();
+
+	// Process sensors, and controllers
+	StartProfile(tc_logic);
+	SG_SetActiveStage(SG_STAGE_CONTROLLER);
+	scene->LogicBeginFrame(current_time);
+	
+	// Scenegraph needs to be updated again, because Logic Controllers 
+	// can affect the local matrices.
+	StartProfile(tc_scenegraph);
+	SG_SetActiveStage(SG_STAGE_CONTROLLER_UPDATE);
+
+	UpdateScenegraph(current_time);
+	
+	// Process actuators
+	// Do some cleanup work for this logic frame
+	StartProfile(tc_logic);
+	SG_SetActiveStage(SG_STAGE_ACTUATOR);
+
+	scene->LogicUpdateFrame(current_time, true);
+	scene->LogicEndFrame();
+	
+	// Actuators can affect the scenegraph
+	StartProfile(tc_scenegraph);
+	SG_SetActiveStage(SG_STAGE_ACTUATOR_UPDATE);
+	UpdateScenegraph(current_time);
+}
+
+// Asks engine to update the message device
+void KX_KetsjiLogicLoop::UpdateMessages()
+{
+if (m_engine->GetNetworkDevice())
+	m_engine->GetNetworkDevice()->NextFrame();
+}
+
+// Asks engine to update mouse events from blender
+void KX_KetsjiLogicLoop::UpdateMouse()
+{
+	if (m_engine->GetMouseDevice())
+		m_engine->GetMouseDevice()->NextFrame();
+}
+
+// Ask engine to update keyboard events from blender
+void KX_KetsjiLogicLoop::UpdateKeyboard()
+{
+
+	if (m_engine->GetKeyboardDevice())
+		m_engine->GetKeyboardDevice()->NextFrame();
+}
+
+// Sets the scene context for context-dependant operations
+void KX_KetsjiLogicLoop::SetCurrentScene(KX_Scene *scene)
+{
+#ifdef WITH_PYTHON
+	PHY_SetActiveEnvironment(scene->GetPhysicsEnvironment());
+#endif
+	KX_SetActiveScene(scene);
+}
+
+KX_Scene *KX_KetsjiLogicLoop::GetCurrentScene()
+{
+	return KX_GetActiveScene();
+}
+
+// Updates scenegraph in context of current scene
+void KX_KetsjiLogicLoop::UpdateScenegraph(double currenttime)
+{
+	KX_GetActiveScene()->UpdateParents(currenttime);
+}
+
+// Updates scenes that were added/destroyed/replaced
+void KX_KetsjiLogicLoop::UpdateScenes()
+{
+	m_engine->ProcessScheduledScenes();
+}
+
+// Receives messages from the "network"
+void KX_KetsjiLogicLoop::ReceiveMessages(double currenttime)
+{
+	KX_GetActiveScene()->GetNetworkScene()->proceed(currenttime);
+}
+
+// Updates animations in context of current scene
+void KX_KetsjiLogicLoop::UpdateAnimations(double currenttime)
+{
+	KX_GetActiveScene()->UpdateAnimations(currenttime);
+}
+
+// Asks engine to update physics in context of current scene
+void KX_KetsjiLogicLoop::UpdatePhysics(double current_time, double deltatime, double interval)
+{
+	if (interval == NULL)
+		interval = deltatime;
+
+	KX_GetActiveScene()->GetPhysicsEnvironment()->proceedDeltaTime(current_time, deltatime, interval);
+
+};
\ No newline at end of file
Index: source/gameengine/Ketsji/KX_KetsjiLogicLoop.h
===================================================================
--- source/gameengine/Ketsji/KX_KetsjiLogicLoop.h	(revision 0)
+++ source/gameengine/Ketsji/KX_KetsjiLogicLoop.h	(working copy)
@@ -0,0 +1,65 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): none yet.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ *
+ */
+
+/** \file KX_KetsjiLogicLoop.h
+ *  \ingroup ketsji
+ */
+
+#ifndef __KX_KETSJILOGICLOOP_H__
+#define __KX_KETSJILOGICLOOP_H__
+
+#include "KX_Python.h"
+#include "KX_WorldInfo.h"
+#include "KX_KetsjiEngine.h"
+
+class KX_KetsjiLogicLoop
+{
+public:
+	KX_KetsjiLogicLoop(KX_KetsjiEngine *engine);
+	//virtual ~KX_KetsjiLogicLoop()=0;
+	KX_KetsjiEngine *m_engine;
+
+	virtual void GiveHandle() = 0;
+	void UpdateKeyboard();
+	void UpdateMouse();
+	void UpdateMessages();
+	void UpdateBlender();
+	void UpdateRender();
+	void UpdateScenes();
+	void StartProfile(int profile_id, double currenttime=NULL, bool stop_others=true);
+	void StopProfile(int profile_id, double currenttime=NULL);
+	void SetCurrentScene(KX_Scene *scene);
+	void ReceiveMessages(double currenttime);
+	void UpdateLogicBricks(double current_time);
+	void UpdateScenegraph(double currenttime);
+	void UpdateAnimations(double currenttime);
+	void UpdatePhysics(double current_time, double deltatime, double interval=NULL);
+	KX_Scene *GetCurrentScene();
+	double GetTime();
+};
+#endif  /* __KX_KETSJILOGICLOOP_H__ */
\ No newline at end of file
Index: source/gameengine/Ketsji/KX_PythonInit.cpp
===================================================================
--- source/gameengine/Ketsji/KX_PythonInit.cpp	(revision 60397)
+++ source/gameengine/Ketsji/KX_PythonInit.cpp	(working copy)
@@ -415,6 +415,52 @@
 	return resultlist;
 }
 
+static PyObject *gPySetAnimationTicRate(PyObject *, PyObject *args)
+{
+	float ticrate;
+	if (!PyArg_ParseTuple(args, "f:setAnimationTicRate", &ticrate))
+		return NULL;
+	
+	KX_KetsjiEngine::SetAnimFrameRate(ticrate);
+	Py_RETURN_NONE;
+}
+
+static PyObject *gPyGetAnimationTicRate(PyObject *)
+{
+	return PyFloat_FromDouble(KX_KetsjiEngine::GetAnimFrameRate());
+}
+
+static PyObject *gPySetUseFrameRate(PyObject *, PyObject *args)
+{
+	bool condition;
+	if (!PyArg_ParseTuple(args, "p:setUseFixedTime", &condition))
+		return NULL;
+	
+	KX_KetsjiEngine::SetUseFixedTime(condition);
+	Py_RETURN_NONE;
+}
+
+static PyObject *gPyGetUseFrameRate(PyObject *)
+{
+	// For some reason m_bFixedTime is false when using fixed timestep
+	return PyBool_FromLong(!KX_KetsjiEngine::GetUseFixedTime());
+}
+
+static PyObject *gPySetRestrictAnimationUpdates(PyObject *, PyObject *args)
+{
+	bool condition;
+	if (!PyArg_ParseTuple(args, "p:setRestrictAnimationUpdates", &condition))
+		return NULL;
+	
+	KX_KetsjiEngine::SetRestrictAnimationFPS(condition);
+	Py_RETURN_NONE;
+}
+
+static PyObject *gPyGetRestrictAnimationUpdates(PyObject *)
+{
+	return PyBool_FromLong(KX_KetsjiEngine::GetRestrictAnimationFPS());
+}
+
 static PyObject *gPySetLogicTicRate(PyObject *, PyObject *args)
 {
 	float ticrate;
@@ -819,23 +865,7 @@
 	return list;
 }
 
-struct PyNextFrameState pynextframestate;
-static PyObject *gPyNextFrame(PyObject *)
-{
-	if (pynextframestate.func == NULL) Py_RETURN_NONE;
-	if (pynextframestate.state == NULL) Py_RETURN_NONE; //should never happen; raise exception instead?
 
-	if (pynextframestate.func(pynextframestate.state)) //nonzero = stop
-	{ 
-		Py_RETURN_TRUE;
-	}
-	else // 0 = go on
-	{
-		Py_RETURN_FALSE;
-	}
-}
-
-
 static struct PyMethodDef game_methods[] = {
 	{"expandPath", (PyCFunction)gPyExpandPath, METH_VARARGS, (const char *)gPyExpandPath_doc},
 	{"startGame", (PyCFunction)gPyStartGame, METH_VARARGS, (const char *)gPyStartGame_doc},
@@ -857,6 +887,12 @@
 	{"setMaxPhysicsFrame", (PyCFunction) gPySetMaxPhysicsFrame, METH_VARARGS, (const char *)"Sets the max number of physics farme per render frame"},
 	{"getLogicTicRate", (PyCFunction) gPyGetLogicTicRate, METH_NOARGS, (const char *)"Gets the logic tic rate"},
 	{"setLogicTicRate", (PyCFunction) gPySetLogicTicRate, METH_VARARGS, (const char *)"Sets the logic tic rate"},
+	{"getUseFrameRate", (PyCFunction) gPyGetUseFrameRate, METH_NOARGS, (const char *)"Gets the status of use frame rate"},
+	{"setUseFrameRate", (PyCFunction) gPySetUseFrameRate, METH_VARARGS, (const char *)"Sets the status of use frame rate"},
+	{"getRestrictAnimationUpdates", (PyCFunction) gPyGetRestrictAnimationUpdates, METH_NOARGS, (const char *)"Gets the status of fixed animation updates"},
+	{"SetRestrictAnimationUpdates", (PyCFunction) gPySetRestrictAnimationUpdates, METH_VARARGS, (const char *)"Sets the status of fixed animation updates"},
+	{"getAnimationTicRate", (PyCFunction) gPyGetAnimationTicRate, METH_NOARGS, (const char *)"Gets the animation tic rate"},
+	{"setAnimationTicRate", (PyCFunction) gPySetAnimationTicRate, METH_VARARGS, (const char *)"Sets the animation tic rate"},
 	{"getPhysicsTicRate", (PyCFunction) gPyGetPhysicsTicRate, METH_NOARGS, (const char *)"Gets the physics tic rate"},
 	{"setPhysicsTicRate", (PyCFunction) gPySetPhysicsTicRate, METH_VARARGS, (const char *)"Sets the physics tic rate"},
 	{"getExitKey", (PyCFunction) gPyGetExitKey, METH_NOARGS, (const char *)"Gets the key used to exit the game engine"},
@@ -865,7 +901,6 @@
 	{"getBlendFileList", (PyCFunction)gPyGetBlendFileList, METH_VARARGS, (const char *)"Gets a list of blend files in the same directory as the current blend file"},
 	{"PrintGLInfo", (PyCFunction)pyPrintExt, METH_NOARGS, (const char *)"Prints GL Extension Info"},
 	{"PrintMemInfo", (PyCFunction)pyPrintStats, METH_NOARGS, (const char *)"Print engine statistics"},
-	{"NextFrame", (PyCFunction)gPyNextFrame, METH_NOARGS, (const char *)"Render next frame (if Python has control)"},
 	{"getProfileInfo", (PyCFunction)gPyGetProfileInfo, METH_NOARGS, gPyGetProfileInfo_doc},
 	/* library functions */
 	{"LibLoad", (PyCFunction)gLibLoad, METH_VARARGS|METH_KEYWORDS, (const char *)""},
@@ -1824,6 +1859,28 @@
 	KX_MACRO_addTypesToDict(d, KX_ACTION_BLEND_BLEND, BL_Action::ACT_BLEND_BLEND);
 	KX_MACRO_addTypesToDict(d, KX_ACTION_BLEND_ADD, BL_Action::ACT_BLEND_ADD);
 
+	/* KX_KetsjiEngine debug modes */
+	KX_MACRO_addTypesToDict(d, KX_ENGINE_DEBUG_PHYSICS, KX_TimeCategory::tc_physics);
+	KX_MACRO_addTypesToDict(d, KX_ENGINE_DEBUG_MESSAGES, KX_TimeCategory::tc_network);
+	KX_MACRO_addTypesToDict(d, KX_ENGINE_DEBUG_ANIMATIONS, KX_TimeCategory::tc_animations);
+	KX_MACRO_addTypesToDict(d, KX_ENGINE_DEBUG_LOGIC, KX_TimeCategory::tc_logic);
+	KX_MACRO_addTypesToDict(d, KX_ENGINE_DEBUG_SCENEGRAPH, KX_TimeCategory::tc_scenegraph);
+	KX_MACRO_addTypesToDict(d, KX_ENGINE_DEBUG_RASTERIZER, KX_TimeCategory::tc_rasterizer);
+	KX_MACRO_addTypesToDict(d, KX_ENGINE_DEBUG_SERVICES, KX_TimeCategory::tc_services);
+	KX_MACRO_addTypesToDict(d, KX_ENGINE_DEBUG_OVERHEAD, KX_TimeCategory::tc_overhead);
+	KX_MACRO_addTypesToDict(d, KX_ENGINE_DEBUG_OUTSIDE, KX_TimeCategory::tc_outside);
+
+	/* Physics type */
+	KX_MACRO_addTypesToDict(d, KX_PHYSICS_STATIC,  KX_GameObject:: STATIC);
+	KX_MACRO_addTypesToDict(d, KX_PHYSICS_DYNAMIC,  KX_GameObject::DYNAMIC);
+	KX_MACRO_addTypesToDict(d, KX_PHYSICS_SENSOR,  KX_GameObject::SENSOR);
+	KX_MACRO_addTypesToDict(d, KX_PHYSICS_CHARACTER,  KX_GameObject::CHARACTER);
+	KX_MACRO_addTypesToDict(d, KX_PHYSICS_SOFT_BODY,  KX_GameObject::SOFT_BODY);
+	KX_MACRO_addTypesToDict(d, KX_PHYSICS_RIGID_BODY,  KX_GameObject::RIGID_BODY);
+	KX_MACRO_addTypesToDict(d, KX_PHYSICS_NAVIGATION_MESH,  KX_GameObject::NAVIGATION_MESH);
+	KX_MACRO_addTypesToDict(d, KX_PHYSICS_NO_COLLISION,  KX_GameObject::NO_COLLISION);
+	KX_MACRO_addTypesToDict(d, KX_PHYSICS_OCCLUDER,  KX_GameObject::OCCLUDER);
+
 	// Check for errors
 	if (PyErr_Occurred())
 	{
Index: source/gameengine/Ketsji/KX_PythonInit.h
===================================================================
--- source/gameengine/Ketsji/KX_PythonInit.h	(revision 60397)
+++ source/gameengine/Ketsji/KX_PythonInit.h	(working copy)
@@ -72,16 +72,6 @@
 class KX_Scene* KX_GetActiveScene();
 class KX_KetsjiEngine* KX_GetActiveEngine();
 
-typedef int (*PyNextFrameFunc)(void *);
-
-struct PyNextFrameState {
-	/** can be either a GPG_NextFrameState or a BL_KetsjiNextFrameState */
-	void *state;
-	/** can be either GPG_PyNextFrame or BL_KetsjiPyNextFrame */
-	PyNextFrameFunc func;
-};
-extern struct PyNextFrameState pynextframestate;
-
 #include "MT_Vector3.h"
 
 void		KX_RasterizerDrawDebugLine(const MT_Vector3& from,const MT_Vector3& to,const MT_Vector3& color);
Index: source/gameengine/Ketsji/KX_PythonInitTypes.cpp
===================================================================
--- source/gameengine/Ketsji/KX_PythonInitTypes.cpp	(revision 60397)
+++ source/gameengine/Ketsji/KX_PythonInitTypes.cpp	(working copy)
@@ -98,6 +98,7 @@
 #include "SCA_RandomActuator.h"
 #include "SCA_IController.h"
 #include "KX_NavMeshObject.h"
+#include "KX_PythonLogicLoop.h"
 
 static void PyType_Attr_Set(PyGetSetDef *attr_getset, PyAttributeDef *attr)
 {
@@ -199,6 +200,7 @@
 		PyType_Ready_Attr(dict, KX_ConstraintWrapper, init_getset);
 		PyType_Ready_Attr(dict, KX_GameActuator, init_getset);
 		PyType_Ready_Attr(dict, KX_GameObject, init_getset);
+		PyType_Ready_Attr(dict, KX_PythonLogicLoop, init_getset);
 		PyType_Ready_Attr(dict, KX_IpoActuator, init_getset);
 		PyType_Ready_Attr(dict, KX_LibLoadStatus, init_getset);
 		PyType_Ready_Attr(dict, KX_LightObject, init_getset);
Index: source/gameengine/Ketsji/KX_PythonLogicLoop.cpp
===================================================================
--- source/gameengine/Ketsji/KX_PythonLogicLoop.cpp	(revision 0)
+++ source/gameengine/Ketsji/KX_PythonLogicLoop.cpp	(working copy)
@@ -0,0 +1,237 @@
+#include "KX_KetsjiEngine.h"
+#include "KX_KetsjiLogicLoop.h"
+#include "PHY_IPhysicsEnvironment.h"
+#include "KX_PyConstraintBinding.h"
+#include "KX_Scene.h"
+#include "KX_PythonLogicLoop.h"
+#include "KX_ISceneConverter.h"
+#include "SCA_IInputDevice.h"
+#include "PyObjectPlus.h"
+
+PyTypeObject KX_PythonLogicLoop::Type = {
+	PyVarObject_HEAD_INIT(NULL, 0)
+	"KX_PythonLogicLoop",
+	sizeof(PyObjectPlus_Proxy),
+	0,
+	py_base_dealloc,
+	0,
+	0,
+	0,
+	0,
+	py_base_repr,
+	0,0,0,0,0,0,0,0,0,
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
+	0,0,0,0,0,0,0,
+	Methods,
+	0,
+	0,
+	&PyObjectPlus::Type,
+	0,0,0,0,0,0,
+	py_base_new
+};
+
+KX_PythonLogicLoop::KX_PythonLogicLoop(KX_KetsjiEngine* engine): KX_KetsjiLogicLoop(engine), PyObjectPlus()
+{
+}
+
+#ifdef WITH_PYTHON
+
+// Define the method accessors
+PyMethodDef KX_PythonLogicLoop::Methods[] = 
+{
+	{"main", (PyCFunction)	KX_PythonLogicLoop::sPyMain, METH_NOARGS},
+	{"start_profile", (PyCFunction)	KX_PythonLogicLoop::sPyStartProfile, METH_VARARGS},
+	{"stop_profile", (PyCFunction)	KX_PythonLogicLoop::sPyStopProfile, METH_VARARGS},
+	{"update_render", (PyCFunction)	KX_PythonLogicLoop::sPyUpdateRender, METH_NOARGS},
+	{"update_blender", (PyCFunction)	KX_PythonLogicLoop::sPyUpdateBlender, METH_NOARGS},
+	{"update_messages", (PyCFunction)	KX_PythonLogicLoop::sPyUpdateMessages, METH_NOARGS},
+	{"update_keyboard", (PyCFunction)	KX_PythonLogicLoop::sPyUpdateKeyboard, METH_NOARGS},
+	{"update_mouse", (PyCFunction)	KX_PythonLogicLoop::sPyUpdateMouse, METH_NOARGS},
+	{"update_logic_bricks", (PyCFunction)	KX_PythonLogicLoop::sPyUpdateLogicBricks, METH_O},
+	{"update_scenes", (PyCFunction)	KX_PythonLogicLoop::sPyUpdateMouse, METH_NOARGS},
+	{"update_physics", (PyCFunction)	KX_PythonLogicLoop::sPyUpdatePhysics, METH_VARARGS},
+	{"receive_messages", (PyCFunction)	KX_PythonLogicLoop::sPyReceiveMessages, METH_O},
+	{"update_scenegraph", (PyCFunction)	KX_PythonLogicLoop::sPyUpdateScenegraph, METH_O},
+	{"update_animations", (PyCFunction)	KX_PythonLogicLoop::sPyUpdateAnimations, METH_O},
+	{"set_current_scene", (PyCFunction)	KX_PythonLogicLoop::sPySetCurrentScene, METH_O},
+	{"check_quit", (PyCFunction)	KX_PythonLogicLoop::sPyCheckQuit, METH_NOARGS},
+	{"get_time", (PyCFunction)	KX_PythonLogicLoop::sPyGetTime, METH_NOARGS},
+	{NULL, NULL} //Sentinel
+};
+
+// Define the attribute accessors
+PyAttributeDef KX_PythonLogicLoop::Attributes[] = {
+	{NULL} //Sentinel
+};
+
+// Default gameloop main method
+PyObject *KX_PythonLogicLoop::PyMain()
+{
+	// By default this is not implemented
+	PyErr_SetString(PyExc_NotImplementedError, "");
+	Py_RETURN_NONE;
+}
+
+// Start profiling a category, shortcut to KX_KetsjiEngine profiler
+PyObject *KX_PythonLogicLoop::PyStartProfile(PyObject *args)
+{
+	int profile_id;
+	bool stop_others = true;
+	double current_time = NULL;
+
+	if (PyArg_ParseTuple(args, "i|db:start_profile", &profile_id, &current_time, &stop_others))
+	{
+		this->StartProfile(profile_id, current_time, stop_others);
+		Py_RETURN_NONE;
+	}
+	return NULL;
+}
+
+// Stop profiling a category
+PyObject *KX_PythonLogicLoop::PyStopProfile(PyObject *args)
+{
+	int profile_id;
+	double current_time = NULL;
+
+	if (PyArg_ParseTuple(args, "i|d:stop_profile", &profile_id, &current_time))
+	{
+		this->StopProfile(profile_id, current_time);
+		Py_RETURN_NONE;
+	}
+	return NULL;
+}
+
+// Set the current scene that is used for the Python API and collisions
+PyObject *KX_PythonLogicLoop::PySetCurrentScene(PyObject *scene)
+{
+	PyObject *name = PyObject_GetAttrString(scene, "name");
+	STR_String scenename = (STR_String)_PyUnicode_AsString(name);
+	Py_DECREF(name);
+
+	KX_Scene *gamescene = m_engine->FindScene(scenename);
+
+	if (!gamescene->IsSuspended())
+		SetCurrentScene(gamescene);
+
+	Py_RETURN_NONE;
+}
+
+// Updates scenes that were added, destroyed or replaced
+PyObject *KX_PythonLogicLoop::PyUpdateScenes()
+{
+	UpdateScenes();
+	Py_RETURN_NONE;
+}
+
+// Updates logic brick systems
+PyObject *KX_PythonLogicLoop::PyUpdateLogicBricks(PyObject *currenttime)
+{
+	UpdateLogicBricks(PyFloat_AsDouble(currenttime));
+	Py_RETURN_NONE;
+}
+
+// Updates scenegraph
+PyObject *KX_PythonLogicLoop::PyUpdateScenegraph(PyObject *currenttime)
+{
+	UpdateScenegraph(PyFloat_AsDouble(currenttime));
+	Py_RETURN_NONE;
+}
+
+// Updates animations
+PyObject *KX_PythonLogicLoop::PyUpdateAnimations(PyObject *currenttime)
+{
+	UpdateAnimations(PyFloat_AsDouble(currenttime));
+	Py_RETURN_NONE;
+}
+
+// Receives messages from loopback
+PyObject *KX_PythonLogicLoop::PyReceiveMessages(PyObject *currenttime)
+{
+	ReceiveMessages(PyFloat_AsDouble(currenttime));
+	Py_RETURN_NONE;
+}
+
+// Updates keyboard after frame
+PyObject *KX_PythonLogicLoop::PyUpdateKeyboard()
+{
+	UpdateKeyboard();
+	Py_RETURN_NONE;
+}
+
+// Updates messages after frame
+PyObject *KX_PythonLogicLoop::PyUpdateMessages()
+{
+	UpdateMessages();
+	Py_RETURN_NONE;
+}
+
+// Updates mouse after frame
+PyObject *KX_PythonLogicLoop::PyUpdateMouse()
+{
+	UpdateMouse();
+	Py_RETURN_NONE;
+}
+
+// Updates keyboard and mouse events
+PyObject *KX_PythonLogicLoop::PyUpdateBlender()
+{
+	UpdateBlender();
+	Py_RETURN_NONE;
+}
+
+// Updates render
+PyObject *KX_PythonLogicLoop::PyUpdateRender()
+{
+	UpdateRender();
+	Py_RETURN_NONE;
+}
+
+// Returns the elapsed time
+PyObject *KX_PythonLogicLoop::PyGetTime()
+{
+	double time = GetTime();
+	PyObject *pytime = PyFloat_FromDouble(time);
+	return pytime;
+}
+
+// Returns quit status
+PyObject *KX_PythonLogicLoop::PyCheckQuit()
+{
+	bool exitstatus = m_engine->GetExitCode();
+ 	return PyBool_FromLong(exitstatus);
+}
+
+// Updates physics
+PyObject *KX_PythonLogicLoop::PyUpdatePhysics(PyObject *args)
+{
+	double current_time, deltatime;
+
+	if (PyArg_ParseTuple(args, "dd:update_physics",  &current_time, &deltatime))
+	{
+		this->UpdatePhysics(current_time, deltatime);
+		Py_RETURN_NONE;
+	}
+	return NULL;
+}
+
+// Set the python class
+void KX_PythonLogicLoop::setPythonClass(PyTypeObject* cls)
+{
+    PyObject* args = Py_BuildValue("(O)", GetProxy());
+    py_base_new(cls, args, NULL);
+    Py_DECREF(args);
+}		
+
+// Runs the "gameloop", typically a while polling the quit status
+void KX_PythonLogicLoop::GiveHandle()
+{
+	PyObject *self = GetProxy();	
+	PyObject *result = PyObject_CallMethod(self, (char*)"main", NULL);
+
+	if (result==NULL)
+	{
+		PyErr_Print();
+	}	
+}
+#endif
+
Index: source/gameengine/Ketsji/KX_PythonLogicLoop.h
===================================================================
--- source/gameengine/Ketsji/KX_PythonLogicLoop.h	(revision 0)
+++ source/gameengine/Ketsji/KX_PythonLogicLoop.h	(working copy)
@@ -0,0 +1,42 @@
+#ifndef __KX_PYTHONLOGICLOOP_H__
+#define __KX_PYTHONLOGICLOOP_H__
+
+#include "KX_KetsjiLogicLoop.h"
+#include "KX_KetsjiEngine.h"
+#include "PyObjectPlus.h"
+
+class KX_PythonLogicLoop : public KX_KetsjiLogicLoop, PyObjectPlus
+{
+	Py_Header
+
+public:
+	KX_PythonLogicLoop(KX_KetsjiEngine *engine);
+
+#ifdef WITH_PYTHON
+	//Define a Python function with the name body of "Main"
+	KX_PYMETHOD_NOARGS(KX_PythonLogicLoop, Main);
+	KX_PYMETHOD_NOARGS(KX_PythonLogicLoop, UpdateBlender);
+	KX_PYMETHOD_NOARGS(KX_PythonLogicLoop, UpdateMessages);
+	KX_PYMETHOD_NOARGS(KX_PythonLogicLoop, UpdateKeyboard);
+	KX_PYMETHOD_NOARGS(KX_PythonLogicLoop, UpdateMouse);
+	KX_PYMETHOD_NOARGS(KX_PythonLogicLoop, GetTime);
+	KX_PYMETHOD_NOARGS(KX_PythonLogicLoop, CheckQuit);
+	KX_PYMETHOD_NOARGS(KX_PythonLogicLoop, UpdateRender);
+	KX_PYMETHOD_NOARGS(KX_PythonLogicLoop, UpdateScenes);
+	KX_PYMETHOD_O(KX_PythonLogicLoop, UpdateLogicBricks);
+	KX_PYMETHOD_O(KX_PythonLogicLoop, UpdateScenegraph);
+	KX_PYMETHOD_O(KX_PythonLogicLoop, UpdateAnimations);
+	KX_PYMETHOD_O(KX_PythonLogicLoop, SetCurrentScene);
+	KX_PYMETHOD_O(KX_PythonLogicLoop, ReceiveMessages);
+	KX_PYMETHOD_VARARGS(KX_PythonLogicLoop, UpdatePhysics);
+	KX_PYMETHOD_VARARGS(KX_PythonLogicLoop, StartProfile);
+	KX_PYMETHOD_VARARGS(KX_PythonLogicLoop, StopProfile);
+
+	void GiveHandle();
+	void setPythonClass(PyTypeObject* cls);
+
+#endif
+
+};
+
+#endif
\ No newline at end of file
Index: source/gameengine/Ketsji/KX_SCA_AddObjectActuator.cpp
===================================================================
--- source/gameengine/Ketsji/KX_SCA_AddObjectActuator.cpp	(revision 60397)
+++ source/gameengine/Ketsji/KX_SCA_AddObjectActuator.cpp	(working copy)
@@ -40,6 +40,7 @@
 #include "KX_GameObject.h"
 #include "KX_IPhysicsController.h"
 #include "PyObjectPlus.h" 
+#include "MT_Matrix4x4.h"
 
 /* ------------------------------------------------------------------------- */
 /* Native functions                                                          */
@@ -253,9 +254,14 @@
 {
 	if (m_OriginalObject)
 	{
+		// Get the gameobject world transform and layer
+		KX_GameObject *obj = (KX_GameObject*)GetParent();
+		MT_Matrix4x4 transform = obj->GetOpenGLMatrix();
+		int layer = obj->GetLayer();
+
 		// Add an identical object, with properties inherited from the original object
 		// Now it needs to be added to the current scene.
-		SCA_IObject* replica = m_scene->AddReplicaObject(m_OriginalObject,GetParent(),m_timeProp );
+		SCA_IObject* replica = m_scene->AddReplicaObject(m_OriginalObject, transform, layer, m_timeProp);
 		KX_GameObject * game_obj = static_cast<KX_GameObject *>(replica);
 		game_obj->setLinearVelocity(m_linear_velocity, m_localLinvFlag);
 		game_obj->setAngularVelocity(m_angular_velocity,m_localAngvFlag);
Index: source/gameengine/Ketsji/KX_Scene.cpp
===================================================================
--- source/gameengine/Ketsji/KX_Scene.cpp	(revision 60397)
+++ source/gameengine/Ketsji/KX_Scene.cpp	(working copy)
@@ -1,34 +1,34 @@
 /*
- * ***** BEGIN GPL LICENSE BLOCK *****
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- * The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
- * All rights reserved.
- *
- * The Original Code is: all of this file.
- *
- * Contributor(s): none yet.
- *
- * ***** END GPL LICENSE BLOCK *****
- * Ketsji scene. Holds references to all scene data.
- */
+* ***** BEGIN GPL LICENSE BLOCK *****
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License
+* as published by the Free Software Foundation; either version 2
+* of the License, or (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software Foundation,
+* Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+* The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
+* All rights reserved.
+*
+* The Original Code is: all of this file.
+*
+* Contributor(s): none yet.
+*
+* ***** END GPL LICENSE BLOCK *****
+* Ketsji scene. Holds references to all scene data.
+*/
 
 /** \file gameengine/Ketsji/KX_Scene.cpp
- *  \ingroup ketsji
- */
+*  \ingroup ketsji
+*/
 
 
 #ifdef _MSC_VER
@@ -36,6 +36,7 @@
 #endif
 
 #include "KX_Scene.h"
+#include "BLI_math.h"
 #include "KX_PythonInit.h"
 #include "MT_assert.h"
 #include "KX_KetsjiEngine.h"
@@ -349,7 +350,7 @@
 
 
 
- 
+
 list<class KX_Camera*>* KX_Scene::GetCameras()
 {
 	return &m_cameras;
@@ -361,11 +362,11 @@
 };
 
 /**
- * Return a const reference to the framing 
- * type set by the above call.
- * The contents are not guaranteed to be sensible
- * if you don't call the above function.
- */
+* Return a const reference to the framing 
+* type set by the above call.
+* The contents are not guaranteed to be sensible
+* if you don't call the above function.
+*/
 const RAS_FrameSettings& KX_Scene::GetFramingType() const 
 {
 	return m_frame_settings;
@@ -374,9 +375,9 @@
 
 
 /**
- * Store the current scene's viewport on the 
- * game engine canvas.
- */
+* Store the current scene's viewport on the 
+* game engine canvas.
+*/
 void KX_Scene::SetSceneViewport(const RAS_Rect &viewport)
 {
 	m_viewport = viewport;
@@ -841,12 +842,21 @@
 	}
 }
 
-
 SCA_IObject* KX_Scene::AddReplicaObject(class CValue* originalobject,
-										class CValue* parentobject,
+										MT_Matrix4x4 transformation,
+										int layer,
 										int lifespan)
 {
+	// Setup matrix
+	float transform[4][4];
+	float loc[3], size[3];
+	float rot[3][3];
 
+	MT_Matrix3x3 orientation;
+	transformation.getValue(*transform);
+	mat4_to_loc_rot_size(loc, rot, size, transform);
+	
+	// Now use
 	m_logicHierarchicalGameObjects.clear();
 	m_map_gameobject_to_replica.clear();
 	m_groupGameObjects.clear();
@@ -854,7 +864,6 @@
 	// todo: place a timebomb in the object, for temporarily objects :)
 	// lifespan of zero means 'this object lives forever'
 	KX_GameObject* originalobj = (KX_GameObject*) originalobject;
-	KX_GameObject* parentobj = (KX_GameObject*) parentobject;
 
 	m_ueberExecutionPriority++;
 
@@ -877,7 +886,6 @@
 	m_parentlist->Add(replica->AddRef());
 
 	// recurse replication into children nodes
-
 	NodeList& children = originalobj->GetSGNode()->GetSGChildren();
 
 	replica->GetSGNode()->ClearSGChildren();
@@ -891,21 +899,19 @@
 
 	// At this stage all the objects in the hierarchy have been duplicated,
 	// we can update the scenegraph, we need it for the duplication of logic
-	MT_Point3 newpos = ((KX_GameObject*) parentobject)->NodeGetWorldPosition();
-	replica->NodeSetLocalPosition(newpos);
+	replica->NodeSetWorldPosition(MT_Point3(loc));
+	//MT_Matrix3x3's constructor expects a 4x4 matrix
+	orientation = MT_Matrix3x3();
+	orientation.setValue3x3(*rot);
+	replica->NodeSetGlobalOrientation(orientation);
 
-	MT_Matrix3x3 newori = ((KX_GameObject*) parentobject)->NodeGetWorldOrientation();
-	replica->NodeSetLocalOrientation(newori);
-	
-	// get the rootnode's scale
-	MT_Vector3 newscale = parentobj->GetSGNode()->GetRootSGParent()->GetLocalScale();
+	// set the replica's relative scale with the transform's scale
+	replica->NodeSetWorldScale(MT_Vector3(size));
 
-	// set the replica's relative scale with the rootnode's scale
-	replica->NodeSetRelativeScale(newscale);
-
 	replica->GetSGNode()->UpdateWorldData(0);
 	replica->GetSGNode()->SetBBox(originalobj->GetSGNode()->BBox());
 	replica->GetSGNode()->SetRadius(originalobj->GetSGNode()->Radius());
+
 	// the size is correct, we can add the graphic controller to the physic engine
 	replica->ActivateGraphicController(true);
 
@@ -922,12 +928,12 @@
 		// this will also relink the actuators in the hierarchy
 		(*git)->Relink(&m_map_gameobject_to_replica);
 		// add the object in the layer of the parent
-		(*git)->SetLayer(parentobj->GetLayer());
+		(*git)->SetLayer(layer);
 		// If the object was a light, we need to update it's RAS_LightObject as well
 		if ((*git)->GetGameObjectType()==SCA_IObject::OBJ_LIGHT)
 		{
 			KX_LightObject* lightobj = static_cast<KX_LightObject*>(*git);
-			lightobj->GetLightData()->m_layer = parentobj->GetLayer();
+			lightobj->GetLightData()->m_layer = layer;
 		}
 	}
 
@@ -955,8 +961,6 @@
 	return replica;
 }
 
-
-
 void KX_Scene::RemoveObject(class CValue* gameobj)
 {
 	KX_GameObject* newobj = (KX_GameObject*) gameobj;
@@ -1642,8 +1646,8 @@
 
 
 /**
- * UpdateParents: SceneGraph transformation update.
- */
+* UpdateParents: SceneGraph transformation update.
+*/
 void KX_Scene::UpdateParents(double curtime)
 {
 	// we use the SG dynamic list
@@ -1780,7 +1784,7 @@
 		m_logicmgr->RegisterEventManager(touchmgr);
 	}
 }
- 
+
 void KX_Scene::setSuspendedTime(double suspendedtime)
 {
 	m_suspendedtime = suspendedtime;
@@ -2387,27 +2391,64 @@
 };
 
 KX_PYMETHODDEF_DOC(KX_Scene, addObject,
-"addObject(object, other, time=0)\n"
+"addObject(object, other, time=0, layer=-1)\n"
 "Returns the added object.\n")
 {
 	PyObject *pyob, *pyother;
 	KX_GameObject *ob, *other;
 
+	MT_Matrix4x4 trans;
+	int layer = -1;
+
 	int time = 0;
 
-	if (!PyArg_ParseTuple(args, "OO|i:addObject", &pyob, &pyother, &time))
+	if (!PyArg_ParseTuple(args, "OO|ii:addObject", &pyob, &pyother, &time, &layer))
 		return NULL;
 
-	if (	!ConvertPythonToGameObject(pyob, &ob, false, "scene.addObject(object, other, time): KX_Scene (first argument)") ||
-			!ConvertPythonToGameObject(pyother, &other, false, "scene.addObject(object, other, time): KX_Scene (second argument)") )
+	// Fix for addObject outside of logic bricks
+	SCA_ILogicBrick::m_sCurrentLogicManager = this->m_logicmgr;
+
+	if (!ConvertPythonToGameObject(pyob, &ob, false, "scene.addObject(object, other, time, layer): KX_Scene (first argument)"))
 		return NULL;
+	
+	// Convert other to gameobject
+	if (!ConvertPythonToGameObject(pyother, &other, false, "scene.addObject(object, other, time, layer): KX_Scene (second argument)"))
+	{
+		// Otherwise try and convert to transform
+		if (!PyMatTo(pyother, trans))
+		{
+			PyErr_Format(PyExc_TypeError, "scene.addObject(object, other, time, layer): KX_Scene (second argument), expect a Matrix (4X4), KX_GameObject or a string");
+			return NULL;
 
+		// This is called after the first exception so we clear it
+		}
+		else
+		{
+			PyErr_Clear();
+		}
+	}
+	
 	if (!m_inactivelist->SearchValue(ob)) {
-		PyErr_Format(PyExc_ValueError, "scene.addObject(object, other, time): KX_Scene (first argument): object must be in an inactive layer");
+		PyErr_Format(PyExc_ValueError, "scene.addObject(object, other, time, layer): KX_Scene (first argument): object must be in an inactive layer");
 		return NULL;
 	}
-	SCA_IObject* replica = AddReplicaObject((SCA_IObject*)ob, other, time);
 	
+	// Get the transform and layer of object
+	if (other)
+	{
+		trans = other->GetOpenGLMatrix();
+		if (layer == -1)
+			layer = other->GetLayer();
+	}
+	// Make sure layer is set
+	else
+	{
+		if (layer == -1)
+			layer = 0;
+	}
+
+	SCA_IObject* replica = AddReplicaObject((SCA_IObject*)ob, trans, layer, time);
+	
 	// release here because AddReplicaObject AddRef's
 	// the object is added to the scene so we don't want python to own a reference
 	replica->Release();
Index: source/gameengine/Ketsji/KX_Scene.h
===================================================================
--- source/gameengine/Ketsji/KX_Scene.h	(revision 60397)
+++ source/gameengine/Ketsji/KX_Scene.h	(working copy)
@@ -44,6 +44,7 @@
 #include "SG_IObject.h"
 #include "SCA_IScene.h"
 #include "MT_Transform.h"
+#include "MT_Matrix4x4.h"
 
 #include "RAS_FramingManager.h"
 #include "RAS_Rect.h"
@@ -326,7 +327,8 @@
 	}
 	void AddObjectDebugProperties(class KX_GameObject* gameobj);
 	SCA_IObject* AddReplicaObject(CValue* gameobj,
-	                              CValue* locationobj,
+	                              MT_Matrix4x4 temp,
+								  int layer,
 	                              int lifespan=0);
 	KX_GameObject* AddNodeReplicaObject(SG_IObject* node,
 	                                    CValue* gameobj);
Index: source/gameengine/Ketsji/KX_TouchEventManager.cpp
===================================================================
--- source/gameengine/Ketsji/KX_TouchEventManager.cpp	(revision 60397)
+++ source/gameengine/Ketsji/KX_TouchEventManager.cpp	(working copy)
@@ -54,13 +54,13 @@
 
 }
 
-bool	KX_TouchEventManager::NewHandleCollision(void* object1, void* object2, const PHY_CollData *coll_data)
+bool	KX_TouchEventManager::NewHandleCollision(void* object1, void* object2, void *coll_data)
 {
-
+	PHY_ContactData *collision_info = static_cast<PHY_ContactData*>(coll_data);
 	PHY_IPhysicsController* obj1 = static_cast<PHY_IPhysicsController*>(object1);
 	PHY_IPhysicsController* obj2 = static_cast<PHY_IPhysicsController*>(object2);
 	
-	m_newCollisions.insert(std::pair<PHY_IPhysicsController*, PHY_IPhysicsController*>(obj1, obj2));
+	m_newCollisions.insert(NewCollision(obj1, obj2, collision_info));
 		
 	return false;
 }
@@ -69,7 +69,7 @@
 bool	 KX_TouchEventManager::newCollisionResponse(void *client_data, 
 							void *object1,
 							void *object2,
-							const PHY_CollData *coll_data)
+							void *coll_data)
 {
 	KX_TouchEventManager *touchmgr = (KX_TouchEventManager *) client_data;
 	touchmgr->NewHandleCollision(object1, object2, coll_data);
@@ -79,7 +79,7 @@
 bool	 KX_TouchEventManager::newBroadphaseResponse(void *client_data, 
 							void *object1,
 							void *object2,
-							const PHY_CollData *coll_data)
+							void *coll_data)
 {
 	PHY_IPhysicsController* ctrl1 = static_cast<PHY_IPhysicsController*>(object1);
 	PHY_IPhysicsController* ctrl2 = static_cast<PHY_IPhysicsController*>(object2);
@@ -90,7 +90,20 @@
 	// This call back should only be called for controllers of Near and Radar sensor
 	if (!info1)
 		return true;
+	
+	// Get KX_GameObjects for callbacks
+	KX_GameObject* gobj1 = info1->m_gameobject;
+	KX_GameObject* gobj2 = (info2) ? info1->m_gameobject : NULL;
+	
+	bool has_py_callbacks;
 
+<<<<<<< .mine
+	// Consider callbacks for broadphase inclusion if it's a sensor object type
+	if (gobj1 && gobj2)
+		has_py_callbacks = gobj1->m_collisionCallbacks || gobj2->m_collisionCallbacks;
+
+	switch (info1->m_type)
+=======
 	// Get KX_GameObjects for callbacks
 	KX_GameObject* gobj1 = info1->m_gameobject;
 	KX_GameObject* gobj2 = (info2) ? info2->m_gameobject : NULL;
@@ -102,6 +115,7 @@
 		has_py_callbacks = gobj1->m_collisionCallbacks || gobj2->m_collisionCallbacks;
 
 	switch (info1->m_type)
+>>>>>>> .r60397
 	{
 	case KX_ClientObjectInfo::SENSOR:
 		if (info1->m_sensors.size() == 1)
@@ -170,17 +184,36 @@
 
 void KX_TouchEventManager::NextFrame()
 {
+<<<<<<< .mine
+	
+=======
+>>>>>>> .r60397
 		SG_DList::iterator<KX_TouchSensor> it(m_sensors);
 		for (it.begin();!it.end();++it)
 			(*it)->SynchronizeTransform();
 		
+<<<<<<< .mine
+		for (NewCollisions::iterator cit = m_newCollisions.begin(); cit != m_newCollisions.end(); ++cit)
+		{			
+			NewCollision collision = (*cit);
+=======
 		for (std::set<NewCollision>::iterator cit = m_newCollisions.begin(); cit != m_newCollisions.end(); ++cit)
 		{
 			// Controllers
 			PHY_IPhysicsController* ctrl1 = (*cit).first;
 			PHY_IPhysicsController* ctrl2 = (*cit).second;
+>>>>>>> .r60397
 
+<<<<<<< .mine
+			// Controllers
+			PHY_IPhysicsController* ctrl1 = get<0>(collision);
+			PHY_IPhysicsController* ctrl2 = get<1>(collision);
+			PHY_ContactData *coll_data = get<2>(collision);
+
 			// Sensor iterator
+=======
+			// Sensor iterator
+>>>>>>> .r60397
 			list<SCA_ISensor*>::iterator sit;
 
 			// First client info
@@ -192,21 +225,51 @@
 				for ( sit = client_info->m_sensors.begin(); sit != client_info->m_sensors.end(); ++sit) {
 					static_cast<KX_TouchSensor*>(*sit)->NewHandleCollision(ctrl1, ctrl2, NULL);
 				}
+<<<<<<< .mine
+ 			}
+
+			// Second client info
+			client_info = static_cast<KX_ClientObjectInfo *>(ctrl2->getNewClientInfo());
+			// Second gameobject
+			KX_GameObject *kxObj2 = KX_GameObject::GetClientObject(client_info);	
+=======
 			}
 
 			// Second client info
 			client_info = static_cast<KX_ClientObjectInfo *>(ctrl2->getNewClientInfo());
 			// Second gameobject
 			KX_GameObject *kxObj2 = KX_GameObject::GetClientObject(client_info);
+>>>>>>> .r60397
 			if (client_info) {
 				for ( sit = client_info->m_sensors.begin(); sit != client_info->m_sensors.end(); ++sit) {
+<<<<<<< .mine
 					static_cast<KX_TouchSensor*>(*sit)->NewHandleCollision(ctrl2, ctrl1, NULL);
+ 				}
+ 			}
+			// Run python callbacks
+			kxObj1->RunCollisionCallbacks(kxObj2, coll_data);
+			kxObj2->RunCollisionCallbacks(kxObj1, coll_data);
+
+			
+			// Delete after passing to function
+			for (PHY_VectCollData::iterator vit = (coll_data->data).begin(); vit != (coll_data->data).end(); ++vit)
+			{
+				delete (*vit);
+=======
+					static_cast<KX_TouchSensor*>(*sit)->NewHandleCollision(ctrl2, ctrl1, NULL);
 				}
+>>>>>>> .r60397
 			}
+<<<<<<< .mine
+			delete coll_data;
+			coll_data = NULL;
+
+=======
 			// Run python callbacks
 			kxObj1->RunCollisionCallbacks(kxObj2);
 			kxObj2->RunCollisionCallbacks(kxObj1);
 
+>>>>>>> .r60397
 		}
 			
 		m_newCollisions.clear();
Index: source/gameengine/Ketsji/KX_TouchEventManager.h
===================================================================
--- source/gameengine/Ketsji/KX_TouchEventManager.h	(revision 60397)
+++ source/gameengine/Ketsji/KX_TouchEventManager.h	(working copy)
@@ -36,33 +36,36 @@
 #include "SCA_EventManager.h"
 #include "KX_TouchSensor.h"
 #include "KX_GameObject.h"
+#include "PHY_DynamicTypes.h"
 
 #include <vector>
 #include <set>
+#include <tuple>
 
 class SCA_ISensor;
 class PHY_IPhysicsEnvironment;
 
 class KX_TouchEventManager : public SCA_EventManager
 {
-	typedef std::pair<PHY_IPhysicsController*, PHY_IPhysicsController*> NewCollision;
+	typedef std::tuple<PHY_IPhysicsController*, PHY_IPhysicsController*, PHY_ContactData *> NewCollision;
+	typedef std::set<NewCollision> NewCollisions;
+
 	PHY_IPhysicsEnvironment*	m_physEnv;
 	
-	std::set<NewCollision> m_newCollisions;
+	NewCollisions m_newCollisions;
 	
-	
 	static bool newCollisionResponse(void *client_data, 
 						void *object1,
 						void *object2,
-						const PHY_CollData *coll_data);
+						void *coll_data);
 
 	static bool newBroadphaseResponse(void *client_data, 
 						void *object1,
 						void *object2,
-						const PHY_CollData *coll_data);
+						void *coll_data);
 
 	virtual bool	NewHandleCollision(void* obj1,void* obj2,
-						const PHY_CollData * coll_data); 
+						void *coll_data);
 
 
 
Index: source/gameengine/Physics/Bullet/CcdPhysicsEnvironment.cpp
===================================================================
--- source/gameengine/Physics/Bullet/CcdPhysicsEnvironment.cpp	(revision 60397)
+++ source/gameengine/Physics/Bullet/CcdPhysicsEnvironment.cpp	(working copy)
@@ -2212,16 +2212,31 @@
 			{
 				const btRigidBody* rb0 = static_cast<const btRigidBody*>(manifold->getBody0());
 				const btRigidBody* rb1 = static_cast<const btRigidBody*>(manifold->getBody1());
-				if (m_debugDrawer && (m_debugDrawer->getDebugMode() & btIDebugDraw::DBG_DrawContactPoints))
+
+				bool draw_points = m_debugDrawer && (m_debugDrawer->getDebugMode() & btIDebugDraw::DBG_DrawContactPoints);
+
+				PHY_ContactData *manifolds = new PHY_ContactData();
+
+				for (int j=0;j<numContacts;j++)
 				{
-					for (int j=0;j<numContacts;j++)
+					const btManifoldPoint& cp = manifold->getContactPoint(j);
+
+					PHY_CollData *coll_data = new PHY_CollData();
+					
+					coll_data->m_point1 = (MT_Vector3)cp.getPositionWorldOnA();
+					coll_data->m_point2 = (MT_Vector3)cp.getPositionWorldOnB();
+					coll_data->m_normal = (MT_Vector3)cp.m_normalWorldOnB;
+					coll_data->m_distance = (MT_Scalar)cp.getDistance();
+
+					(manifolds->data).push_back(coll_data);
+
+					if (draw_points)
 					{
 						btVector3 color(1,0,0);
-						const btManifoldPoint& cp = manifold->getContactPoint(j);
-						if (m_debugDrawer)
-							m_debugDrawer->drawContactPoint(cp.m_positionWorldOnB,cp.m_normalWorldOnB,cp.getDistance(),cp.getLifeTime(),color);
+						m_debugDrawer->drawContactPoint(cp.m_positionWorldOnB,cp.m_normalWorldOnB,cp.getDistance(),cp.getLifeTime(),color);
 					}
 				}
+
 				const btRigidBody* obj0 = rb0;
 				const btRigidBody* obj1 = rb1;
 
@@ -2234,12 +2249,14 @@
 				{
 					i = m_triggerControllers.find(ctrl1);
 				}
-
+				
 				if (!(i == m_triggerControllers.end()))
 				{
 					m_triggerCallbacks[PHY_OBJECT_RESPONSE](m_triggerCallbacksUserPtrs[PHY_OBJECT_RESPONSE],
-						ctrl0,ctrl1,0);
+						ctrl0, ctrl1, manifolds);
 				}
+
+
 				// Bullet does not refresh the manifold contact point for object without contact response
 				// may need to remove this when a newer Bullet version is integrated
 				if (!dispatcher->needsResponse(rb0, rb1))
@@ -2249,6 +2266,7 @@
 					// Let's just clear the manifold, in any case, it is recomputed on each frame.
 					manifold->clearManifold(); //refreshContactPoints(rb0->getCenterOfMassTransform(),rb1->getCenterOfMassTransform());
 				}
+				
 			}
 		}
 
Index: source/gameengine/Physics/common/PHY_DynamicTypes.h
===================================================================
--- source/gameengine/Physics/common/PHY_DynamicTypes.h	(revision 60397)
+++ source/gameengine/Physics/common/PHY_DynamicTypes.h	(working copy)
@@ -21,6 +21,7 @@
 #define __PHY_DYNAMICTYPES_H__
 
 #include "MT_Vector3.h"
+#include <vector>
 
 struct KX_ClientObjectInfo;
 
@@ -40,13 +41,19 @@
 	MT_Vector3 m_point1;               /* Point in object1 in world coordinates */
 	MT_Vector3 m_point2;               /* Point in object2 in world coordinates */
 	MT_Vector3 m_normal;               /* point2 - point1 */
+	MT_Scalar m_distance;
 } PHY_CollData;
 
+typedef std::vector <PHY_CollData*> PHY_VectCollData;
 
+typedef struct PHY_ContactData{
+	PHY_VectCollData data;
+} PHY_ContactData;
+
 typedef bool (*PHY_ResponseCallback)(void *client_data,
                                      void *client_object1,
                                      void *client_object2,
-                                     const PHY_CollData *coll_data);
+                                     void *coll_data);
 typedef void (*PHY_CullingCallback)(KX_ClientObjectInfo* info, void* param);
 
 
